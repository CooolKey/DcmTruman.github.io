<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cm_2019年8月13日</title>
      <link href="/2019/08/12/cm_day_20190813/"/>
      <url>/2019/08/12/cm_day_20190813/</url>
      
        <content type="html"><![CDATA[<h1 id="cm-2019年08月13日"><a href="#cm-2019年08月13日" class="headerlink" title="cm_2019年08月13日"></a>cm_2019年08月13日</h1><p><em>因为之前自闭了几天，所以没写日报，我又回来啦(还好意思说…..)</em></p><a id="more"></a><h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><p>花了一上午的时间用来补ccpc吉林那到现场赛的题，昨晚想自闭了，后来<strong>顿悟</strong>，觉得自己的lazy写复杂了，完全没必要lazy维护直接加减的数值，而维护前面后面应该添哪些数即可，还要维护一下要当前位数和要push的位数，更新的时候也不能用<code>log10</code>得到位数，要手动传入。顺便写了个题解。没看题解最终把它搞出来了我还挺开心的，瞬间不自闭了。可以还是想来很久，现场赛的话，还是不一定能想出来。</p><h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>下午调试的很心累，平衡树有个地方不该加<strong>引用</strong>我却加了，然后调了好久。</p><p>主要挑了一些树套树的裸题，自己手敲，来锻炼对数据结构的理解和实现能力。</p><p>洛谷上的<strong>二逼平衡树</strong>,先是用线段树套平衡树的思想做了，但理论复杂度其实是在超时的边缘徘徊，再加上treap随机值要看脸，所以有一两个用例T了，重新交又不T了……</p><p>然后一气之下，用<strong>主席树套树状数组</strong>有重新敲了一下，一开始还不太清楚前驱后继怎么搞，后来想想，直接就几个查询排名和查询第k大组合一下就行了，还是很巧妙的，<strong>主席树牛逼！树状数组牛逼</strong></p><h2 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h2><p>晚上看了几个题，No Pain No Game<a href="https://vjudge.net/problem/45786/origin" target="_blank" rel="noopener">HDU - 4630</a> 还是挺有意思的一道题，一开始我们都想到要求出每个数的因子，区间因子出现2的，主席树好像不太好做，然后我去考虑贡献，离线去更新r对l的贡献，这里先记一下思路，貌似我的想法还要用到吉司机线段树？明天补一下，期望不会自闭</p>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> cm </tag>
            
            <tag> 树套树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cm_HDU6562 题解</title>
      <link href="/2019/08/12/cm_hdu6562/"/>
      <url>/2019/08/12/cm_hdu6562/</url>
      
        <content type="html"><![CDATA[<h1 id="cm-HDU6562-题解"><a href="#cm-HDU6562-题解" class="headerlink" title="cm_HDU6562 题解"></a>cm_HDU6562 题解</h1><p><em>其实这一篇我也想放在学习笔记那里，因为昨晚写这个题的时候我都不好意思说自己学过带lazy的线段树…</em></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>两种操作，</p><ol><li>$w,l,r,d$，把区间里的每个数，前面加上一个d，后面加上一个d，比如原来是3，d是4，这个数之后就变成了434，注意，根据样例可以发现，前导0也要算的，比如前后加0，变成030，这时候在前后加4，就是40304，而不是4304</li><li>$ q,l,r$，询问区间和</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>两头加一个d，我们先假设d一位数，（为什么要假设呢，因为我们延迟更新的话，向下更新的数可能是好几位），对sum的贡献就是</p><p>$$sum = sum \times 10 + (r - l + 1) \times d + 10 \times  d \times \sum_{i=l}^{r} 10^{len_{a_{i}}}$$</p><p>线段树的每个节点需要有$sum$，同时还需要维护一下$\sum_{i=l}^{r} 10^{len_{a_{i}}}$</p><p>当前节点的更新好说，问题是如果要带延迟，该怎么更新呢，我用来两个lazy标记，<code>lazyd</code>表示右边要拼的数，<code>lazym</code>表示左边要拼的数，那么我们延迟的思想就是，我们一次可以拼好几个数，也就没必要深入到底下一个一个修改，用到再push。</p><p>再加上上面的题目描述，所以我们还需要知道，当前拼的数是几位数，注意，这道题里，0是1位，00是2位，更新的时候也就更新多位数，<code>vald</code>表示后面拼的数，<code>valm</code>表示前面拼的数，<code>wei</code>表示要拼的数的位数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sum = sum * qpow(<span class="number">10</span>,wei,mod) % mod;</span><br><span class="line">sum = (sum + (r-l+<span class="number">1</span>) * vald % mod) % mod;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "len10=" &lt;&lt; len10 &lt;&lt; " ";</span></span><br><span class="line">sum = (sum + valm * len10 % mod * qpow(<span class="number">10</span>,wei,mod) % mod)%mod;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "sum="&lt;&lt; sum &lt;&lt; endl;</span></span><br><span class="line">len10 = len10 * qpow(<span class="number">10</span>,<span class="number">2l</span>l * wei,mod)%mod;</span><br><span class="line">lazyd = (lazyd * qpow(<span class="number">10</span>,wei,mod) % mod + vald) % mod;</span><br><span class="line">lazym = (valm * qpow(<span class="number">10</span>,lazywei,mod) % mod + lazym) % mod;</span><br><span class="line">lazywei = (lazywei + wei) % mod;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) x &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) x &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">       <span class="keyword">if</span>(b &amp; (ll)<span class="number">1</span>)res = res * a % m;</span><br><span class="line">       a = a * a % m;</span><br><span class="line">       b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll inv = qpow(<span class="number">10</span>,mod<span class="number">-2</span>,mod);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll len10,sum;</span><br><span class="line">    ll lazyd,lazym,lazywei;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll vald,ll valm,ll wei)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sum = sum * qpow(<span class="number">10</span>,wei,mod) % mod;</span><br><span class="line">        sum = (sum + (r-l+<span class="number">1</span>) * vald % mod) % mod;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "len10=" &lt;&lt; len10 &lt;&lt; " ";</span></span><br><span class="line">        sum = (sum + valm * len10 % mod * qpow(<span class="number">10</span>,wei,mod) % mod)%mod;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "sum="&lt;&lt; sum &lt;&lt; endl;</span></span><br><span class="line">        len10 = len10 * qpow(<span class="number">10</span>,<span class="number">2l</span>l * wei,mod)%mod;</span><br><span class="line">        lazyd = (lazyd * qpow(<span class="number">10</span>,wei,mod) % mod + vald) % mod;</span><br><span class="line">        lazym = (valm * qpow(<span class="number">10</span>,lazywei,mod) % mod + lazym) % mod;</span><br><span class="line">        lazywei = (lazywei + wei) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[maxn * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[x].sum = (tree[lson(x)].sum + tree[rson(x)].sum) % mod;</span><br><span class="line">    tree[x].len10 = (tree[lson(x)].len10 + tree[rson(x)].len10 ) %mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll la = tree[x].lazywei;</span><br><span class="line">    <span class="keyword">if</span>(la)&#123;</span><br><span class="line">        tree[lson(x)].update(tree[x].lazyd,tree[x].lazym,tree[x].lazywei);</span><br><span class="line">        tree[rson(x)].update(tree[x].lazyd,tree[x].lazym,tree[x].lazywei);</span><br><span class="line">        tree[x].lazyd = tree[x].lazym = <span class="number">0</span>;</span><br><span class="line">        tree[x].lazywei = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[x].l = l,tree[x].r = r;</span><br><span class="line">    tree[x].sum = tree[x].lazyd = tree[x].lazym = tree[x].lazywei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tree[x].len10 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(lson(x),l,mid);</span><br><span class="line">    build(rson(x),mid+<span class="number">1</span>,r);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; l &lt;&lt;  " " &lt;&lt; r&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> L = tree[x].l,R = tree[x].r;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">        tree[x].update(val,val,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)update(lson(x),l,r,val);</span><br><span class="line">    <span class="keyword">if</span>(mid &lt;r)update(rson(x),l,r,val);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = tree[x].l,R = tree[x].r;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[x]. sum;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res = (res + query(lson(x),l,r)) % mod;</span><br><span class="line">    <span class="keyword">if</span>(mid &lt;r)res = (res + query(rson(x),l,r)) % mod;</span><br><span class="line">    pushup(x);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,ql,qr;</span><br><span class="line">ll qk;</span><br><span class="line"><span class="keyword">char</span> ss[<span class="number">7</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> kase=<span class="number">1</span>;kase&lt;=T;kase++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>,kase);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,ss);</span><br><span class="line">            <span class="keyword">if</span>(ss[<span class="number">0</span>] == <span class="string">'w'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>,&amp;ql,&amp;qr,&amp;qk);</span><br><span class="line">                update(<span class="number">1</span>,ql,qr,qk);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;ql,&amp;qr);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(<span class="number">1</span>,ql,qr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 数据结构 </category>
          
          <category> 线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 题解 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cm_二逼平衡树p3380 题解 (板子题)</title>
      <link href="/2019/08/12/cm_p3380/"/>
      <url>/2019/08/12/cm_p3380/</url>
      
        <content type="html"><![CDATA[<h1 id="cm-二逼平衡树p3380-题解-板子题"><a href="#cm-二逼平衡树p3380-题解-板子题" class="headerlink" title="cm_二逼平衡树p3380 题解 (板子题)"></a>cm_二逼平衡树p3380 题解 (板子题)</h1><p>如果是线段树套平衡树，那么线段树每个节点都是一个平衡树，每个节点记录所代表的的平衡树的根节点即可，板子题，但是我用的无旋treap得看脸…经常会T…打脸打得疼，之前说不用担心被恶意构造数据卡，结果被自己的人品卡了，复杂度$O(nlogn^{3} )$</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) T[(x)].lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) T[(x)].rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) x &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) x &lt;&lt; 1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> lc,rc,size,key;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125;T[maxn * <span class="number">40</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Random</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> sed, A, C, M;</span><br><span class="line">  Random(<span class="keyword">int</span> sed = rand(), <span class="keyword">int</span> A = <span class="number">48271</span>, <span class="keyword">int</span> C = <span class="number">57</span>, <span class="keyword">int</span> M = <span class="number">2147483647</span>)</span><br><span class="line">      : sed(sed), A(A), C(C), M(M) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">out</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (sed = ((A * sed + C) % M)); &#125;</span><br><span class="line">&#125; A;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">'-'</span> &amp;&amp; (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>))</span><br><span class="line">        ch = getchar();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">        flag = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,n,tot;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="comment">//mt19937 myrand(time(0));</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nnode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,rt;</span><br><span class="line">&#125;tree[maxn * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">T[x].size = T[lson(x)].size + T[rson(x)].size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)&#123;</span><br><span class="line">x = y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T[root].val &lt;= val)&#123;</span><br><span class="line">x = root;</span><br><span class="line">Split(rson(root),rson(x),y,val);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">y = root;</span><br><span class="line">Split(lson(root),x,lson(y),val);</span><br><span class="line">&#125;</span><br><span class="line">Pushup(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> &amp;root,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x || !y)&#123;</span><br><span class="line">root = x+y;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T[x].key &lt; T[y].key)&#123;</span><br><span class="line">root = x;</span><br><span class="line">Merge(rson(root),rson(x),y);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">root = y;</span><br><span class="line">Merge(lson(root),x,lson(y));</span><br><span class="line">&#125;</span><br><span class="line">Pushup(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> &amp;root,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>,y = <span class="number">0</span>,z = ++tot;</span><br><span class="line">T[z].val = val;T[z].key = A.out();T[z].size = <span class="number">1</span>;</span><br><span class="line">T[z].lc = T[z].rc = <span class="number">0</span>;</span><br><span class="line">Split(root,x,y,val);</span><br><span class="line">Merge(x,x,z);</span><br><span class="line">Merge(root,x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">int</span> &amp;root,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>,y = <span class="number">0</span>,z = <span class="number">0</span>;</span><br><span class="line">Split(root,x,y,val);</span><br><span class="line">Split(x,x,z,val<span class="number">-1</span>);</span><br><span class="line">Merge(z,lson(z),rson(z));</span><br><span class="line">Merge(x,x,z);</span><br><span class="line">Merge(root,x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getrank</span><span class="params">(<span class="keyword">int</span> &amp;root ,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>,y = <span class="number">0</span>,z = <span class="number">0</span>;</span><br><span class="line">Split(root,x,y,val<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> res = T[x].size;</span><br><span class="line">Merge(root,x,y);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_rank</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L = tree[x].l,R = tree[x].r;</span><br><span class="line"><span class="comment">//cout &lt;&lt; L &lt;&lt; " " &lt;&lt; R &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span>(l &lt;= L &amp;&amp; R &lt;= r)<span class="keyword">return</span> Getrank(tree[x].rt,val);</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid)res += query_rank(ls(x),l,r,val);</span><br><span class="line"><span class="keyword">if</span>(mid &lt; r)res += query_rank(rs(x),l,r,val);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Knum</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T[lson(root)].size + <span class="number">1</span> == k)<span class="keyword">return</span> T[root].val;</span><br><span class="line"><span class="keyword">if</span>(T[lson(root)].size &gt;= k)<span class="keyword">return</span> Knum(lson(root),k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> Knum(rson(root),k - T[lson(root)].size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pre</span><span class="params">(<span class="keyword">int</span> &amp;root,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>,y = <span class="number">0</span>,z = <span class="number">0</span>;</span><br><span class="line">Split(root,x,y,val<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> res = -INF;</span><br><span class="line"><span class="keyword">if</span>(T[x].size)res = Knum(x,T[x].size);</span><br><span class="line">Merge(root,x,y);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_pre</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L = tree[x].l,R = tree[x].r;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= L &amp;&amp; R &lt;= r)<span class="keyword">return</span> Pre(tree[x].rt,val);</span><br><span class="line"><span class="keyword">int</span> res = -INF;</span><br><span class="line"><span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid)res = max(res , query_pre(ls(x),l,r,val));</span><br><span class="line"><span class="keyword">if</span>(mid &lt; r)res = max(res,query_pre(rs(x),l,r,val));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_knum</span><span class="params">(<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; mid&lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(query_rank(<span class="number">1</span>,ql,qr,mid+<span class="number">1</span>) &gt;= k)&#123;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">ans = mid;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Suf</span><span class="params">(<span class="keyword">int</span> &amp;root,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>,y = <span class="number">0</span>,z = <span class="number">0</span>;</span><br><span class="line">Split(root,x,y,val);</span><br><span class="line"><span class="keyword">int</span> res = INF;</span><br><span class="line"><span class="keyword">if</span>(T[y].size)res = Knum(y,<span class="number">1</span>);</span><br><span class="line">Merge(root,x,y);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_suf</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L = tree[x].l,R = tree[x].r;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= L &amp;&amp; R &lt;= r)<span class="keyword">return</span> Suf(tree[x].rt,val);</span><br><span class="line"><span class="keyword">int</span> res = INF;</span><br><span class="line"><span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid)res = min(res , query_suf(ls(x),l,r,val));</span><br><span class="line"><span class="keyword">if</span>(mid &lt; r)res = min(res,query_suf(rs(x),l,r,val));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[x].l = l;tree[x].r = r;</span><br><span class="line">tree[x].rt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(ls(x),l,mid);</span><br><span class="line">build(rs(x),mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L = tree[x].l,R = tree[x].r;</span><br><span class="line">Insert(tree[x].rt,val);</span><br><span class="line"><span class="keyword">if</span>(L == R)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid)Add(ls(x),pos,val);</span><br><span class="line"><span class="keyword">else</span> Add(rs(x),pos,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L = tree[x].l,R = tree[x].r;</span><br><span class="line">Erase(tree[x].rt,val);</span><br><span class="line"><span class="keyword">if</span>(L == R)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid)Delete(ls(x),pos,val);</span><br><span class="line"><span class="keyword">else</span> Delete(rs(x),pos,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L = tree[x].l,R = tree[x].r;</span><br><span class="line"><span class="keyword">if</span>(L == R)<span class="keyword">return</span> T[tree[x].rt].val;</span><br><span class="line"><span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid)<span class="keyword">return</span> query(ls(x),pos);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(rs(x),pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmpval = query(<span class="number">1</span>,pos);</span><br><span class="line"><span class="comment">//cout &lt;&lt; tmpval &lt;&lt; endl;</span></span><br><span class="line">Delete(<span class="number">1</span>,pos,tmpval);</span><br><span class="line">Add(<span class="number">1</span>,pos,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">n=read();m=read();</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="comment">// srand(19260817);</span></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">tmp = read();</span><br><span class="line">Add(<span class="number">1</span>,i,tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> op,ql,qr,qk;</span><br><span class="line"><span class="keyword">while</span>(m --)&#123;</span><br><span class="line">op = read();</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">ql=read();qr=read();qk=read();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query_rank(<span class="number">1</span>,ql,qr,qk)+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">ql=read();qr=read();qk=read();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query_knum(ql,qr,qk));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>)&#123;</span><br><span class="line">ql=read();qk=read();</span><br><span class="line">Change(ql,qk);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">4</span>)&#123;</span><br><span class="line">ql=read();qr=read();qk=read();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query_pre(<span class="number">1</span>,ql,qr,qk));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">5</span>)&#123;</span><br><span class="line">ql=read();qr=read();qk=read();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query_suf(<span class="number">1</span>,ql,qr,qk));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树状数组 + 主席树也可做，如何找前驱呢？找它在区间的排名，看看这个区间有多少个这个数，用num记录，然后找区间里第k-num大的数是多少，后继同理，复杂度$O(nlogn^{2})$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) T[(x)].lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) T[(x)].rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> lc,rc,num,fa;</span><br><span class="line">&#125;T[maxn * <span class="number">400</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">qst</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> op,ql,qr,qk;</span><br><span class="line">&#125;qst[maxn];</span><br><span class="line"><span class="keyword">int</span> root[maxn],n,m,tot;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> lower_bound(v.begin(),v.end(),x) - v.begin() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=++tot;T[x] = T[y];</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">T[x].num += val;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid)update(lson(y),lson(x),l,mid,pos,val);</span><br><span class="line"><span class="keyword">else</span> update(rson(y),rson(x),mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">T[x].num = T[lson(x)].num + T[rson(x)].num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_a</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> pos,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">update(c[i],c[i],<span class="number">1</span>,<span class="number">1e5</span>,pos,x);</span><br><span class="line">i += lowbit(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> aa[maxn],bb[maxn],cnt1,cnt2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum_a</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">aa[cnt1++] = c[x];</span><br><span class="line">x -= lowbit(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(y &gt; <span class="number">0</span>)&#123;</span><br><span class="line">bb[cnt2++] = c[y];</span><br><span class="line">y -= lowbit(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_knum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)<span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt1;i++)&#123;</span><br><span class="line">tmp -= T[lson(aa[i])].num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt2;i++)&#123;</span><br><span class="line">tmp += T[lson(bb[i])].num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span>(tmp &gt;= k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt1;i++)&#123;</span><br><span class="line">aa[i] = lson(aa[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt2;i++)&#123;</span><br><span class="line">bb[i] = lson(bb[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> query_knum(l,mid,k);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt1;i++)&#123;</span><br><span class="line">aa[i] = rson(aa[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt2;i++)&#123;</span><br><span class="line">bb[i] = rson(bb[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> query_knum(mid+<span class="number">1</span>,r,k- tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp_num;</span><br><span class="line"><span class="keyword">int</span> tmp_val;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_rank</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//cout </span></span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt1;i++)&#123;</span><br><span class="line">tmp -= T[(aa[i])].num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt2;i++)&#123;</span><br><span class="line">tmp += T[(bb[i])].num;</span><br><span class="line">&#125;</span><br><span class="line">tmp_num = tmp;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt1;i++)&#123;</span><br><span class="line">tmp -= T[lson(aa[i])].num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt2;i++)&#123;</span><br><span class="line">tmp += T[lson(bb[i])].num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k &lt;= mid)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt1;i++)&#123;</span><br><span class="line">aa[i] = lson(aa[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt2;i++)&#123;</span><br><span class="line">bb[i] = lson(bb[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> query_rank(l,mid,k);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt1;i++)&#123;</span><br><span class="line">aa[i] = rson(aa[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt2;i++)&#123;</span><br><span class="line">bb[i] = rson(bb[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp + query_rank(mid+<span class="number">1</span>,r,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn],ql,qr,qk,op;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;arr[i]);</span><br><span class="line">v.push_back(arr[i]);</span><br><span class="line"><span class="comment">// update_a(i,arr[i],1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span> || op == <span class="number">2</span> || op == <span class="number">4</span> || op == <span class="number">5</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;qst[i].ql,&amp;qst[i].qr,&amp;qst[i].qk);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;qst[i].ql,&amp;qst[i].qk);</span><br><span class="line">&#125;</span><br><span class="line">qst[i].op = op;</span><br><span class="line"><span class="keyword">if</span>(op!=<span class="number">2</span>)v.push_back(qst[i].qk);</span><br><span class="line">&#125;</span><br><span class="line">sort(v.begin(),v.end());</span><br><span class="line">v.erase(unique(v.begin(),v.end()),v.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">arr[i] = getid(arr[i]);</span><br><span class="line">update_a(i,arr[i],<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="comment">//scanf("%d",&amp;op);</span></span><br><span class="line">op = qst[i].op;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//scanf("%d%d%d",&amp;ql,&amp;qr,&amp;qk);</span></span><br><span class="line">ql = qst[i].ql;qr = qst[i].qr;qk = getid(qst[i].qk);</span><br><span class="line">getsum_a(ql<span class="number">-1</span>,qr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query_rank(<span class="number">1</span>,<span class="number">1e5</span>,qk)-tmp_num + <span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//scanf("%d%d%d",&amp;ql,&amp;qr,&amp;qk);</span></span><br><span class="line">ql = qst[i].ql;qr = qst[i].qr;qk=qst[i].qk;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ql &lt;&lt; " " &lt;&lt; qr &lt;&lt; " " &lt;&lt; qk &lt;&lt; endl;</span></span><br><span class="line">getsum_a(ql<span class="number">-1</span>,qr);</span><br><span class="line"><span class="comment">//cout &lt;&lt; cnt1 &lt;&lt; " " &lt;&lt; cnt2 &lt;&lt; endl;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,v[query_knum(<span class="number">1</span>,<span class="number">1e5</span>,qk)<span class="number">-1</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//scanf("%d%d",&amp;ql,&amp;qk);</span></span><br><span class="line">ql = qst[i].ql;qk = getid(qst[i].qk);</span><br><span class="line">update_a(ql,arr[ql],<span class="number">-1</span>);</span><br><span class="line">update_a(ql,qk,<span class="number">1</span>);</span><br><span class="line">arr[ql] = qk;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="comment">//tmp_num = 0;</span></span><br><span class="line"><span class="comment">//scanf("%d%d%d",&amp;ql,&amp;qr,&amp;qk);</span></span><br><span class="line">ql = qst[i].ql;qr = qst[i].qr;qk = getid(qst[i].qk);</span><br><span class="line">getsum_a(ql<span class="number">-1</span>,qr);</span><br><span class="line"><span class="keyword">int</span> tmpk = query_rank(<span class="number">1</span>,<span class="number">1e5</span>,qk);</span><br><span class="line"><span class="keyword">if</span>(tmpk == tmp_num)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,-INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tmp_num == <span class="number">0</span>)&#123;</span><br><span class="line">getsum_a(ql<span class="number">-1</span>,qr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,v[query_knum(<span class="number">1</span>,<span class="number">1e5</span>,tmpk)<span class="number">-1</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">getsum_a(ql<span class="number">-1</span>,qr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,v[query_knum(<span class="number">1</span>,<span class="number">1e5</span>,tmpk-tmp_num)<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">5</span>)&#123;</span><br><span class="line"><span class="comment">//scanf("%d%d%d",&amp;ql,&amp;qr,&amp;qk);</span></span><br><span class="line">ql = qst[i].ql;qr = qst[i].qr;qk = getid(qst[i].qk);</span><br><span class="line">getsum_a(ql<span class="number">-1</span>,qr);</span><br><span class="line"><span class="keyword">int</span> tmpk = query_rank(<span class="number">1</span>,<span class="number">1e5</span>,qk);</span><br><span class="line"><span class="keyword">if</span>(tmpk == (qr-ql+<span class="number">1</span>))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,INF);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">getsum_a(ql<span class="number">-1</span>,qr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,v[query_knum(<span class="number">1</span>,<span class="number">1e5</span>,tmpk+<span class="number">1</span>)<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 题解 </tag>
            
            <tag> 主席树 </tag>
            
            <tag> 树套树 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 平衡树 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Key_2019年8月12日</title>
      <link href="/2019/08/11/Key_day_20190812/"/>
      <url>/2019/08/11/Key_day_20190812/</url>
      
        <content type="html"><![CDATA[<h1 id="Key-2019年8月12日"><a href="#Key-2019年8月12日" class="headerlink" title="Key_2019年8月12日"></a>Key_2019年8月12日</h1><p>上午下午看完了约数的小节</p><p><a href="https://vjudge.net/problem/HYSBZ-1257" target="_blank" rel="noopener">BZOJ1257</a>  余数之和（数论分块）</p><p><a href="https://www.acwing.com/problem/content/202/" target="_blank" rel="noopener">CH3201</a>  给定abcd,求满足gcd(a,x)=c,lcm(b,x)=d的x个数（因数分解后限定范围）</p><a id="more"></a><p><a href="https://vjudge.net/problem/POJ-3090" target="_blank" rel="noopener">POJ3090</a>  求(n,n)范围内gcd(x,y)=1的对数</p><p>晚上的欧拉定理看晕啦(因为想起了上学期学得乱七八糟的信安数学)…明天再写总结8</p>]]></content>
      
      
      <categories>
          
          <category> Key </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> Key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xyw_2019年8月12日</title>
      <link href="/2019/08/11/xyw_day_20190812/"/>
      <url>/2019/08/11/xyw_day_20190812/</url>
      
        <content type="html"><![CDATA[<h1 id="xyw5vplus1-2019-08-12"><a href="#xyw5vplus1-2019-08-12" class="headerlink" title="xyw5vplus1_2019.08.12"></a>xyw5vplus1_2019.08.12</h1><h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><p>养身ing……</p><p>看了个Miller Robin的原理和代码，把kuangbin的改成了自己的代码风格</p><a id="more"></a><h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>线段树ing</p><p>过了线段树区间最值操作的模板题  HDU 5306  </p><p>对lazy标记打得有点不清不楚的（果然为晚上的遭遇埋下了伏笔</p><p>只在特定条件下lazy标记有效</p><p>然后开始看一些杂题，BZOJ的也有不太难的啦，有裸的树链剖分、线段树+思维什么的</p><p>然后要维护蛮多信息的那种</p><p>CF 500E着实想了很久，做法感觉是没问题，就是想得蛮麻烦的，最后用了并查集，虽然感觉跟并查集的关系也不是很大，标答的做法貌似有用倍增加速的，怎么就有点忘了……果然确实还是不能做到融汇贯通</p><p>不过题目真的蛮有意思的，第一次见到用<strong>线段树加速DP转移</strong>的</p><p>下午的最后，给自己埋了一个大坑……2018 CCPC 吉林金牌题，被我们当成了一道傻逼题……</p><p>于是乎</p><h2 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h2><p>吃完饭回来的路上就意识到lazy标记的叠加会有问题，然后就开始想做法了，最后时间紧的时候直接就上手写了，维护的信息基本正确，但就是想不太清楚怎么pushdown，怎么update了……</p><p>确实确实不太明白难题当中lazy标记的使用了……</p><p>最后“大约”看明白了题解，但脑子里还是一团浆糊，明天需要重新研究一下<strong>lazy标记的本质</strong>。</p><p>果然，<em>离金牌数据结构题还是有差距的</em>，接下来的一段时间，<strong><em>线段树进阶题</em></strong>，  </p><p>嗯，我们来发起冲击了……</p>]]></content>
      
      
      <categories>
          
          <category> xyw </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> xyw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xyw_2019年8月11日</title>
      <link href="/2019/08/10/xyw_day_20190811/"/>
      <url>/2019/08/10/xyw_day_20190811/</url>
      
        <content type="html"><![CDATA[<p>xyw5vplus1_2019.08.11</p><h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><p>说好不写题的呢？说好只写几分钟的呢？</p><p>开了一道HDU6287 18年女生赛的题，主席树+数论什么的一些搞一搞，</p><p>整个思路还挺清晰的，于是乎写的也非常顺利，很快就调出了样例</p><p>然而，</p><p>还是卡了一个多小时……</p><p>即使在网上找到了一个思路极其相近的也没有改出来，</p><p>最后，只好启用我的本地终极武器——<strong>对拍</strong></p><p>结果我的对拍就“崩了”……   什么鬼……</p><p>结果是自己的数据生成的cpp文件写错了，少读了点东西，导致两个程序都在那边等输入，没有返回。</p><p>意识到错误的我在修改完之后很快就发现了错误，是在比较特殊的情况下，主席树在建立的过程中会断开，导致后面会出问题。已经整理到错误合集中了</p><p>好在是在网络赛之前复习了对拍的使用，为网络赛可能会大规模使用对拍做铺垫。</p><p>感觉这种码力不算很小的题现在写得明显快多了，代码块之间的组织也清晰了不少，不过可能是因为主席树写得还是有点少，所以一些细节处理得还是不够好。</p><p>继续坚持我的<strong>“搭积木”式的代码块构建理论</strong>：使用一些数据结构的时候我觉得更稳妥的做法是<strong>沿用大的基本框架，个别修改几个重点的函数</strong>，这样方便找错；然后函数要写得更*<em>“面向调用” *</em>一些。</p><p>嗯，感觉有时间的话可以<strong>整理一下自己的代码风格的理论</strong>，对构建相对大一些的复杂一些的程序会节省不少时间，思路也会理得更清楚一些。</p><h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>无</p><h2 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h2><p>8点半的CF</p><p>A题签到，B题贪心签到不过WA了一发，C题数学题还蛮有意思的，感觉这种非常源于生活的自己就不太能出得出来。（突然意识到我们要下半年校赛出题了）D题自己写的超级麻烦，用了6个二维的布尔数组，6个二维的求和数组。看标签有数据结构、双指针。打算有时间的时候学习一下简单的做法。E题感觉是个裸的扩展KMP，（留下了不会字符串的眼泪……感觉KMP、扩展KMP这种最基本的自己还是要会的。</p><p>最后 Rank 531 涨了59分</p>]]></content>
      
      
      <categories>
          
          <category> xyw </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> xyw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Key_2019年8月10日</title>
      <link href="/2019/08/09/key_day_20190810/"/>
      <url>/2019/08/09/key_day_20190810/</url>
      
        <content type="html"><![CDATA[<h1 id="Key-2019年8月10日"><a href="#Key-2019年8月10日" class="headerlink" title="Key_2019年8月10日"></a>Key_2019年8月10日</h1><p>回来训练的第一天，感觉手更生了反应更慢了大脑也更迟钝了5555555</p><p>上午继续写了一会算法竞赛上的递归</p><a id="more"></a><p><a href="https://vjudge.net/problem/POJ-1958" target="_blank" rel="noopener">POJ1958</a>  4个盘子的汉诺塔 <em>（从3个盘子的情况推过来）</em></p><p><a href="https://vjudge.net/problem/POJ-1845" target="_blank" rel="noopener">POJ1845</a>  $A^B$的约数之和<em>（分治法等比数列求和）</em></p><p><a href="https://vjudge.net/problem/POJ-3889" target="_blank" rel="noopener">POJ3889</a>  分形</p><p>问题还是思路不清晰，代码写得太乱，导致代码里有很多小错误，debug起来很麻烦，过题也慢。</p><p>记住记住<strong>完全想清楚再开始敲！</strong></p><p>下午看了一点数论，发现很多概念定理都忘了…菜鸡落泪.jpg</p><p>晚上写了两道简单dp，好像没感受到什么状态转移的感觉</p>]]></content>
      
      
      <categories>
          
          <category> Key </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> Key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xyw_2019年8月10日</title>
      <link href="/2019/08/09/xyw_day_20190810/"/>
      <url>/2019/08/09/xyw_day_20190810/</url>
      
        <content type="html"><![CDATA[<h1 id="xyw5vplus1-2019-08-10"><a href="#xyw5vplus1-2019-08-10" class="headerlink" title="xyw5vplus1_2019.08.10"></a>xyw5vplus1_2019.08.10</h1><p>终于回归了！好吧不过今天依然不敢太用力做题，时常还是会有头昏脑涨的迹象……</p><a id="more"></a><h2 id="欧拉降幂公式应用"><a href="#欧拉降幂公式应用" class="headerlink" title="欧拉降幂公式应用"></a>欧拉降幂公式应用</h2><p>BZOJ 3884 上帝与集合的正确用法  Get it !</p><p>UVA 10692 Huge Mods  Get it !</p><p>POJ 2720 Last Digits  <strong>TLE！！！</strong></p><p>终于明白了一堆变态的指数再取模该怎么求，个别有些小细节的处理也还是要当心，关键的思想就是把<strong>个数减小或者把模数减小，不断利用欧拉降幂公式就OK了</strong>。再次为南昌的比赛的失误错失金牌默哀n分钟……当时的思路基本也是对的，就20分钟实在是出不来啊&gt;_&lt;</p><p><em>UVA的那道题输入特别坑，但是居然用cin就特别简单，不知道为什么？？？</em></p><p>周一问一下楚盟师哥 </p><h2 id="斐波那契数列循环节"><a href="#斐波那契数列循环节" class="headerlink" title="斐波那契数列循环节"></a>斐波那契数列循环节</h2><p>继前几天完成矩阵快速幂板子的调整之后，终于向着13长沙的金牌数学题进发了。</p><p>沿着唐老师的结论和当时的规律，改了一个上午终于也是过了。</p><p>中间爆了一发long long ，换成O(1)快速乘之后才过的，也已经在板子里面标注了。</p><p>结论已经整理到板子里去了。</p><p>再次体会到了模块化写代码的好处。</p>]]></content>
      
      
      <categories>
          
          <category> xyw </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> xyw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cm_2019年8月9日</title>
      <link href="/2019/08/08/cm_day_20190809/"/>
      <url>/2019/08/08/cm_day_20190809/</url>
      
        <content type="html"><![CDATA[<p>这两天还是挺自闭的，无论是codeforces还是牛客多校，自己简单题居然卡了好久，由于钻牛角尖浪费了很多时间最后也没出来。真的真的很菜。</p><p>昨晚一气之下，爆肝到好晚（今天能起来我真是佩服自己）,顺便就学了一下treap。</p><a id="more"></a><p>今天搞了一天的无旋treap，顺便a了几道题，写了<a href="https://dcmtruman.github.io/2019/08/08/cm_learn_fhqtreap/">学习笔记</a>，说一下心路历程吧。</p><p>最近写数据结构总爱犯的错误就是节点搞错，要么是传错参数，要么是用错，今天写treap也犯过不少这种错误。然后是递归的时候返回是的条件写错了。还有读题读错，没看到多组用例。还有，写一道题的时候，stl用太多了，超内存了，最后干脆不用stl，直接计算贡献，才解决的。</p><p>fhqtreap很好写，我更加感受到了递归的魅力，无论是<code>Split</code>还是<code>Merge</code>，都是短短五行左右，基本操作也就30行，非常优雅。</p><p>emmm还在吃午饭和晚饭的时候顺便看了一下<strong>支配树</strong>，感觉也很有用的样子。</p><hr><p>今天的新说唱很好看，果然歌曲要用心打磨，更要用时间打磨才行，急忙赶出来的作品，听感还是挺差的。杨和苏走了，不过很快还会再回来，估计是拿了去年艾热的剧本。看到他和狐狸拍的那个广告，真实太有爱了，露出姨母笑……</p>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> cm </tag>
            
            <tag> fhqtreap </tag>
            
            <tag> treap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cm_无旋treap学习笔记&amp;&amp;HDU6162题解（2017多校）</title>
      <link href="/2019/08/08/cm_learn_fhqtreap/"/>
      <url>/2019/08/08/cm_learn_fhqtreap/</url>
      
        <content type="html"><![CDATA[<h1 id="cm-无旋treap学习笔记-amp-amp-HDU6162题解（2017多校）"><a href="#cm-无旋treap学习笔记-amp-amp-HDU6162题解（2017多校）" class="headerlink" title="cm_无旋treap学习笔记&amp;&amp;HDU6162题解（2017多校）"></a>cm_无旋treap学习笔记&amp;&amp;HDU6162题解（2017多校）</h1><p>老实讲，关于平衡树的题，我并没有怎么做过，去年为了LCT而学了splay，但也只是做了版子题，一些区间操作、第k问题balabala，我基本上是能用 线段树/主席树 搞就不用别的。但为了练一些<strong>树套树</strong>的题，以及为了在数据结构上学的更深入一些，我决定开始最近研究一下平衡树！</p><a id="more"></a><h2 id="二叉查找树-BST"><a href="#二叉查找树-BST" class="headerlink" title="二叉查找树(BST)"></a>二叉查找树(BST)</h2><p>所谓二叉查找树就是在二叉树的基础上，满足这么一个性质：对于树上的每个节点，其左子树的任一节点的权值均小于当前节点，右子树任一节点的权值均大于当前点</p><p>BST的形态是可以多种多样的，最坏的时候也】可以退化到一个链，但无论怎么样，其中序遍历的结果始终都是相同的。在一些区间问题上，平衡树的做法中常常以数组位置为BST的关键值，无论怎么操作，只要满足BST性质，都是可以还原原来的数组序列的。</p><h2 id="BST的旋转"><a href="#BST的旋转" class="headerlink" title="BST的旋转"></a>BST的旋转</h2><p>这个还是有必要记一下的，之前因为不怎么写，老是记不住。</p><p>我们可以通过一些操作改变树的结构，同时仍然保证BST的性质。接下来我们讨论的均是孩子和爸爸互换位置的情况</p><p>右旋 ： 假设x是y的左儿子，根据性质，x的值是小于y和y的右子树的，x当爸爸，那么y和y的右子树都成为了x的右儿子，那么原来x的右儿子该去哪里呢？x原来是y的左儿子，现在变成y的父亲了，y的左儿子就空出来了，把x的右儿子和右子树整体接到y的左儿子即可，依然满足性质。<br>左旋 ： 类似的思想。</p><h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><p>刚才说了，BST最坏情况下退化成链，查找什么的也就成了$O(n)$了，这样一点也不优雅，那么为了让这棵树看起来更像棵树，高度尽可能接近$logn$，我们就需要时刻改变树的结构，来保持”平衡“，同时还要依然保证二叉查找树的性质。常见的平衡树有splay、treap、替罪羊书、红黑树等，他们保证”平衡“的手段各不相同，今天说的treap，是一种利用随机权值来达到期望$logn$复杂度的数据结构。</p><p>首先说一下堆。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>二叉堆在结构上看起来和树很相似。常常用来维护最值。大根堆中，任何一个孩子的权值都比父亲小，小根堆中，任何一个孩子的权值都比父亲大。插入的时候，直接放到堆最后一个位置，然后$logn$的复杂度不断进行父亲和儿子的权值比较及替换，以满足具体的性质。</p><p>取最值的时候，O(1)时间取堆顶。</p><h2 id="treap"><a href="#treap" class="headerlink" title="treap"></a>treap</h2><p>treap，顾名思义，tree + heap的一种数据结构，每个点有两个权值<code>val</code>和<code>key</code>，其中<code>val</code>满足二叉平衡树的性质，<code>key</code>满足小根堆的性质。</p><p>简单说就是，我们现在有一颗BST，插入值的时候，按照BST的性质插入，同时我们给这个节点附一个随机的<code>key</code>，用来满足小根堆的性质，如果儿子的<code>key</code>小于父亲，就进行旋转操作改变结构，将小的放在上面。</p><p>因为是随机值，所以我们的树的结构不会因为诡异的插入数据或者超级超级差的人品而退化成链，出题人想卡都比较难，复杂度期望是$logn$的，我也不太会证，大概理解一下就行。</p><h2 id="fhqtreap-无旋treap"><a href="#fhqtreap-无旋treap" class="headerlink" title="fhqtreap 无旋treap"></a>fhqtreap 无旋treap</h2><p>看名字大概能猜出来，无旋treap是一种不用旋转的treap。这时候有人说了，你放屁！不通过旋转该别树的结构，怎么既维护二叉查找树的性质，又维护小根堆的性质？！且听我慢慢说。</p><p>无旋treap有两个核心操作——<strong>分裂</strong>和<strong>合并</strong></p><h3 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h3><p>假设你已经有一颗fhqtreap了，先不管怎么来的，分裂要干的事就是，给定一个value，把你当前的树拆成两颗不同x和y，其中树x的值均小于等于value，树y的值均大于value。</p><p>怎么实现的，通过递归和引用即可，非常好写。我们的函数给四个参数，根据val把以root为根的树分裂给x和y</p><p>我们首先看一下当前根节点的权值，如果小于val，就把当前根节点和左子树全部接给x，然后把root的右子树分裂给x的右子树和y。大于val同理。</p><p>这种分法，可以保证分裂出来的两个数仍然满足BST的性质，树x的值均小于等于value，树y的值均大于value。且第二权值仍然满足小根堆的性质（如果分裂前的树就满足的话）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> &amp;root,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)&#123;x=y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(tree[root].val&lt;=val)&#123;x=root;Split(rson(root),rson(x),y,val);&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;y=root;Split(lson(root),x,lson(y),val);&#125;</span><br><span class="line">Pushup(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>假设你有了两颗fhqtreap，一颗小于等于val，一颗大于val，怎么合并才能不破坏两种性质呢？</p><p>我们比较x和y根节点的key值（key是维护小根堆性质用到的值），如果x的小于y，则y出现在x节点的下面，保证了小根堆得性质。由于树y的每个节点的val值均大于x，此时只需要合并x的右子树和树y即可，保证了新的合并的树的BST性质。大于同理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> &amp;root,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x || !y)&#123;root=x+y;<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(tree[x].key &lt; tree[y].key)&#123;root=x;Merge(rson(root),rson(x),y);&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;root=y;Merge(lson(root),x,lson(y));&#125;</span><br><span class="line">Pushup(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面两个操作，我们就可以改变树的形态来满足性质，而又不使用旋转。同时还能花式解决许多类型的问题，比如把某个值域范围的数提取成一颗树，或者某个区间的数提取成一棵树。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>新开一个节点z，假设要插入的值为value，z的val为value，key随机生成，根据value把树分为x和y，合并z和x至x，在合并x和y至root即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">int</span> &amp;root,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>,z=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">Split(root,x,y,val);</span><br><span class="line">Split(x,x,z,val<span class="number">-1l</span>l);</span><br><span class="line">Merge(z,lson(z),rson(z));</span><br><span class="line">Merge(x,x,z);</span><br><span class="line">Merge(root,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>假设删除值为value的一个点，我们通过分裂操作，把全是value的点放到一棵树里，合并其左右孩子节点（即删掉根节点）,然后在合并回去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">int</span> &amp;root,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>,z=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">Split(root,x,y,val);</span><br><span class="line">Split(x,x,z,val<span class="number">-1l</span>l);</span><br><span class="line">Merge(z,lson(z),rson(z));</span><br><span class="line">Merge(x,x,z);</span><br><span class="line">Merge(root,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无旋treap就说这么多，代码也是比较好写的，前驱后继k大啥的和别的平衡树没太大区别，听说可持久treap大都用这种无旋的方式来写，改天我也会专门写一下可持久化的fhqtreap学习笔记。</p><h2 id="HDU6162题解"><a href="#HDU6162题解" class="headerlink" title="HDU6162题解"></a>HDU6162题解</h2><p>给你一棵树，$n$个点，$m$个询问，$1\leq n,m \leq 10^{5}$每个点权值$1\leq c_{i}\leq 10^{9}$,问你$s$到$t$的路径上，权值在$l$到$r$之间的权值之和是多少</p><p>主席树在线可以搞，但这里为了练习平衡树，就离线了。利用容斥可以很快得到答案，需要四个关键点，s,t,lca(s,t)和lca(s,t)的父亲</p><p>假设<code>mp[x][y]</code>表示从根节点到x节点，权值小于等于y的值的总和，那么从根节点到x节点，区间在<code>[l,r]</code>的总和是<code>mp[x][r]-mp[x][l-1]</code>，从x到y，区间在<code>[l,r]</code>的总和是<code>mp[x][r]-mp[x][l-1]+mp[y][r]-mp[y][l-1]-(mp[lca(x,y)][r]-mp[lca(x,y)][l-1])-(mp[fa[lca(x,y)]][r]-mp[fa[lca(x,y)]][l-1])</code></p><p>离线做，在关键点上记录要查询哪些东西。dfs这棵树，每次dfs进入这个节点，就把这个点的权值加入平衡树，如果当前是关键点，有一个查询<code>ql</code>在这里，去平衡树里，根据<code>ql</code>分裂成x树和y树，其中x树的权值和<code>sum</code>就是查询的答案（根到当前点权值小于<code>ql</code>的值得总和），<code>sum</code>通过<code>Pushup</code>函数来维护。</p><p>离开这个点的时候，再把它删除掉。</p><p>一开始我专门用了个map来记录，超内存了……其实不用，我们通过type标记一下加还是减，在dfs过程中把贡献加进ans中即可。</p><p>多组用例，记得清空~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) T[(x)].lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) T[(x)].rc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100020</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> lc,rc,key,size;</span><br><span class="line">ll val,sum;</span><br><span class="line">&#125;T[maxn];</span><br><span class="line"><span class="keyword">int</span> rt,tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">T[x].size = T[lson(x)].size + T[rson(x)].size + <span class="number">1</span>;</span><br><span class="line">T[x].sum = T[lson(x)].sum + T[rson(x)].sum + T[x].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)&#123;x=y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(T[root].val &lt;= val)&#123;x=root;Split(rson(root),rson(x),y,val);&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;y=root;Split(lson(root),x,lson(y),val);&#125;</span><br><span class="line">Pushup(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> &amp;root,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x || !y)&#123;root=x+y;<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(T[x].key &lt; T[y].key)&#123;root=x;Merge(rson(root),rson(x),y);&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;root=y;Merge(lson(root),x,lson(y));&#125;</span><br><span class="line">Pushup(root);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> &amp;root,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>,z=++tot;</span><br><span class="line">T[z].val=val;T[z].key=rand();T[z].sum=val;T[z].size=<span class="number">1</span>;</span><br><span class="line">T[z].lc = T[z].rc = <span class="number">0</span>;</span><br><span class="line">Split(root,x,y,val);</span><br><span class="line">Merge(x,x,z);</span><br><span class="line">Merge(root,x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">int</span> &amp;root,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>,z=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">Split(root,x,y,val);</span><br><span class="line">Split(x,x,z,val<span class="number">-1l</span>l);</span><br><span class="line">Merge(z,lson(z),rson(z));</span><br><span class="line">Merge(x,x,z);</span><br><span class="line">Merge(root,x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Knum</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(T[lson(root)].size == k<span class="number">-1</span>)<span class="keyword">return</span> T[root].val;</span><br><span class="line"><span class="keyword">if</span>(T[lson(root)].size &gt;= k)<span class="keyword">return</span> Knum(lson(root),k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> Knum(rson(root),k-T[lson(root)].size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ll cc[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qst</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">ll ql,type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;qst&gt;G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">edge[cnt].to = v;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[maxn][<span class="number">21</span>],deep[maxn],vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[now] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">19</span>;i++)&#123;</span><br><span class="line">fa[now][i] = fa[fa[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];~i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> to = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!vis[to])&#123;</span><br><span class="line">fa[to][<span class="number">0</span>] = now;</span><br><span class="line">deep[to] = deep[now] + <span class="number">1</span>;</span><br><span class="line">dfs1(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[u] &lt; deep[v])swap(u,v);</span><br><span class="line"><span class="keyword">int</span> dis = deep[u] - deep[v];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; i) &amp; dis)u=fa[u][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==v)<span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[u][i] != fa[v][i])&#123;</span><br><span class="line">u = fa[u][i];</span><br><span class="line">v= fa[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(<span class="keyword">int</span> &amp;root,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">Split(root,x,y,val);</span><br><span class="line">ll ret = T[x].sum;</span><br><span class="line">Merge(root,x,y);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">ll ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; now &lt;&lt; endl;</span></span><br><span class="line">Insert(rt,cc[now]);</span><br><span class="line"><span class="keyword">int</span> sz = G[now].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;sz;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> id = G[now][i].id;</span><br><span class="line">ans[id] += cal(rt, G[now][i].ql)*G[now][i].type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];~i;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(to != f)&#123;</span><br><span class="line">dfs2(to,now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Erase(rt,cc[now]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">cnt = tot = rt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">G[i].clear();</span><br><span class="line">deep[i]=<span class="number">0</span>;</span><br><span class="line">head[i] = <span class="number">-1</span>;</span><br><span class="line">vis[i] = <span class="literal">false</span>;</span><br><span class="line">ans[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">19</span>;j++)fa[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">init(n+<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;cc[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> aa,bb;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;aa,&amp;bb);</span><br><span class="line">addedge(aa,bb);</span><br><span class="line">addedge(bb,aa);</span><br><span class="line">&#125;</span><br><span class="line">deep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">dfs1(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; "fuck" &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line">ll ql,qr;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lld%lld"</span>,&amp;u,&amp;v,&amp;ql,&amp;qr);</span><br><span class="line"><span class="keyword">int</span> fx = lca(u,v);</span><br><span class="line"><span class="keyword">int</span> fxx = fa[fx][<span class="number">0</span>];</span><br><span class="line">G[u].push_back((qst)&#123;i,ql<span class="number">-1</span>,<span class="number">-1</span>&#125;);</span><br><span class="line">G[u].push_back((qst)&#123;i,qr,<span class="number">1</span>&#125;);</span><br><span class="line">G[v].push_back((qst)&#123;i,ql<span class="number">-1</span>,<span class="number">-1</span>&#125;);</span><br><span class="line">G[v].push_back((qst)&#123;i,qr,<span class="number">1</span>&#125;);</span><br><span class="line">G[fx].push_back((qst)&#123;i,ql<span class="number">-1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">G[fx].push_back((qst)&#123;i,qr,<span class="number">-1</span>&#125;);</span><br><span class="line">G[fxx].push_back((qst)&#123;i,ql<span class="number">-1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">G[fxx].push_back((qst)&#123;i,qr,<span class="number">-1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i)<span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 数据结构 </category>
          
          <category> 平衡树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> treap </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构相关习题列表</title>
      <link href="/2019/08/06/chairmantree_20190801/"/>
      <url>/2019/08/06/chairmantree_20190801/</url>
      
        <content type="html"><![CDATA[<h1 id="一些可持久化线段树习题"><a href="#一些可持久化线段树习题" class="headerlink" title="一些可持久化线段树习题"></a>一些可持久化线段树习题</h1><ul><li><input checked disabled type="checkbox"> <strong>HDU 6621</strong> 多校，二分距离，对于一个mid来说，权值分布落在$[q-mid,q+mid]$的个数肯定是单调的，然后就转换成了区间找「在某个范围内的数」，主席树查询即可 </li><li><input disabled type="checkbox"> <strong>HDU 5788</strong> 多校，中位数建主席树</li><li><input disabled type="checkbox"> <strong>Bzoj 2653</strong>（可持久化线段树；二分答案；按数值大小更新对应位置的+1-1，每个元素对应一个线段树，求最大连续最短和）</li><li><input disabled type="checkbox"> <strong>Bzoj 3123</strong>(启发式合并)</li><li><input checked disabled type="checkbox"> <strong>codeforces 786C</strong> 算复杂度，倒插主席树</li><li><input checked disabled type="checkbox"> <strong>codeforces 538F</strong> 计算复杂度，主席树</li><li><input checked disabled type="checkbox"> <strong>codeforces 547E</strong> fail树，dfs序，可持久化线段树</li><li><input checked disabled type="checkbox"> Bzoj 3674 可持久化并查集 ， 用线段树可持久化维护fa数组</li><li><input checked disabled type="checkbox"> ZOJ 2112 动态主席树</li><li><input disabled type="checkbox"> HDU 6287 底层维护素数个数，分解质因数，「乘除」变成「加减」</li><li><input disabled type="checkbox"> Zoj 4053 逆序对，每次只会影响一个区间变成两个，堆维护一下，计算逆序对贡献用主席树求区间比m大的个数，即可</li><li><input disabled type="checkbox"> HDU 6601 最坏情况是斐波那契，增长很快，上限 $10^{9}$ ,所以只需要求第k大，k+1大、…、k+44大即可<a id="more"></a></li><li><input checked disabled type="checkbox"> Bzoj 1926（裸）</li><li><input checked disabled type="checkbox"> Bzoj 2588（裸）</li><li><input checked disabled type="checkbox"> Bzoj 3932(<strong>查询的时候跟k比较的是左节点数量！！！！！</strong>)</li><li><input disabled type="checkbox"> Bzoj 3207 hash+主席树</li><li><input disabled type="checkbox"> Bzoj 2809 主席树+dfs序，枚举管理者，$nlog_{2}n$,我当时的想法是递归的时候孩子合并到父亲上，儿子递归完更新答案</li><li><input disabled type="checkbox"> HDU 3727 (裸)</li><li><input disabled type="checkbox"> HDU 4417 (裸)</li><li><input disabled type="checkbox"> HDU 4348 (枚举中位数位置)</li></ul><h1 id="线段树相关习题"><a href="#线段树相关习题" class="headerlink" title="线段树相关习题"></a>线段树相关习题</h1><ul><li><input disabled type="checkbox"> Codeforces 500e 线段树加速dp+倍增/并查集/倒序离线</li><li><input disabled type="checkbox"> Hdu 5306 吉司机线段树</li><li><input disabled type="checkbox"> Bzoj 2957 线段树+思维 y/x</li></ul>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 数据结构 </category>
          
          <category> 主席树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主席树 </tag>
            
            <tag> 题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cm_可持久化trie树学习笔记 + BZOJ 3261/P4592 [TJOI2018]题解</title>
      <link href="/2019/08/06/cm_learn_trie_iijq/"/>
      <url>/2019/08/06/cm_learn_trie_iijq/</url>
      
        <content type="html"><![CDATA[<h1 id="cm-可持久化trie树学习笔记-BZOJ-3261-P4592-TJOI2018-题解"><a href="#cm-可持久化trie树学习笔记-BZOJ-3261-P4592-TJOI2018-题解" class="headerlink" title="cm_可持久化trie树学习笔记 + BZOJ 3261/P4592 [TJOI2018]题解"></a>cm_可持久化trie树学习笔记 + BZOJ 3261/P4592 [TJOI2018]题解</h1><p><em>主席树的题，虽然嘴巴ac了不少，但是还是得练啊</em></p><p><em>当然，每天除了做主席树，在别的方面也得看啊！</em></p><p>刚好今天学习了fail树上的一些应用，既然是字符串，刚好最近在看可持久化的数据结构，不如就顺便看看可持久化的trie树吧。</p><p>顺便，安利一本书，<strong>《算法竞赛进阶指南》</strong></p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>初始给你长度为$n$的一个序列$a$，有两种操作，一是在序列后在添加一个数$x$，二是让你在$[l,r]$区间选一个$p$，使得$a[p]\oplus a[p+1]\oplus …a[r]\oplus x$的值最大.</p><h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2><ul><li>trie树</li><li>可持久化数据结构思想</li></ul><h2 id="可持久化trie树"><a href="#可持久化trie树" class="headerlink" title="可持久化trie树"></a>可持久化trie树</h2><p>因为之前在练主席树，所以学习了一下发现，核心思想都差不多，就是<strong>「每次操作只增加需要增加的节点，不变的节点仍然和上一次状态保持一致」</strong></p><p>然后…然后好像就没有然后了…</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题分三个部分，我们一点一点看</p><h3 id="1-问题转化"><a href="#1-问题转化" class="headerlink" title="1. 问题转化"></a>1. 问题转化</h3><p>首先，先不要考虑关于区间的问题</p><p>利用异或的性质，我们可以将它转化为类似前缀和处理。我们先得到前缀异或和$s$数组。如果要求$a[p]\oplus a[p+1]\oplus … a[n]\oplus x$，其实就是求$s[p-1]\oplus s[n]\oplus x$，其中$s[n]\oplus x$是固定值，这里用$val$代替。也就是我们要在数组$s$中找一个$s[p-1]$，使得$s[p-1]\oplus val$最大</p><p>如果没有区间的限制，只需要对$s$中每个数01比特建一课异或trie树，然后拿着val尽可能往反方向走就行。</p><h3 id="2-右边界限制"><a href="#2-右边界限制" class="headerlink" title="2. 右边界限制"></a>2. 右边界限制</h3><p>其实右区间限制也好说，我们只需要用第$r$个历史版本即可，因为此时右边界右边的数还没有插到trie树中。历史版本用可持久化trie树做就行。</p><h3 id="3-左边界限制"><a href="#3-左边界限制" class="headerlink" title="3. 左边界限制"></a>3. 左边界限制</h3><p>左边界限制，我们需要同时在维护一个T[x].latest，表示到达这个节点最近的一次是通过数组中的第几个节点，其实就是维护一下数组位置的$max$，然后递归查询的时候，准备递归的节点的latest，必须$\ge limit$（其中$limit$是左边界限制），否则就递归另一个孩子</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注意，转换成前缀和数组的问题后，我们的区间$[l,r]$就成了新的问题中的$[l-1,r-1]$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">600020</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> lc,rc,latest;</span><br><span class="line">&#125;T[maxn*<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,tot,root[maxn],arr[maxn],s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = ++tot;T[x] = T[y];</span><br><span class="line"><span class="keyword">if</span>(k &lt; <span class="number">0</span>)&#123;</span><br><span class="line">T[x].latest = i;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c = (s[i] &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!c)update(T[y].lc,T[x].lc,i,k<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span> update(T[y].rc,T[x].rc,i,k<span class="number">-1</span>);</span><br><span class="line">T[x].latest = max(T[T[x].lc].latest,T[T[x].rc].latest);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k,<span class="keyword">int</span> val,<span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k &lt; <span class="number">0</span>)<span class="keyword">return</span> s[T[x].latest] ^ val;</span><br><span class="line"><span class="keyword">int</span> c = (val &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(c)&#123;</span><br><span class="line"><span class="keyword">if</span>(T[T[x].lc].latest &gt;= limit)<span class="keyword">return</span> query(T[x].lc,k<span class="number">-1</span>,val,limit);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(T[x].rc,k<span class="number">-1</span>,val,limit);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T[T[x].rc].latest &gt;= limit)<span class="keyword">return</span> query(T[x].rc,k<span class="number">-1</span>,val,limit);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(T[x].lc,k<span class="number">-1</span>,val,limit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> sss[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    T[<span class="number">0</span>].latest=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;arr[i]);</span><br><span class="line">    s[i] = s[i<span class="number">-1</span>] ^ arr[i];</span><br><span class="line">    update(root[i<span class="number">-1</span>],root[i],i,<span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> now_len = n;</span><br><span class="line"><span class="keyword">char</span> cc;<span class="keyword">int</span> x,ql,qr;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,sss);</span><br><span class="line"><span class="keyword">if</span>(sss[<span class="number">0</span>] == <span class="string">'A'</span>)&#123;</span><br><span class="line">now_len ++;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">s[now_len] = s[now_len - <span class="number">1</span>] ^ x;</span><br><span class="line">update(root[now_len<span class="number">-1</span>],root[now_len],now_len,<span class="number">23</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;ql,&amp;qr,&amp;x);</span><br><span class="line"><span class="keyword">int</span> val = s[now_len] ^ x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(root[qr<span class="number">-1</span>],<span class="number">23</span>,val,ql<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，还有一种写法，是利用了前缀和相减的性质，通过计算个数，判断是否能往相反跳，过程中统计答案，下面是Oi-Wiki的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">600010</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, a[maxn], s[maxn], l, r, x;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> cnt, rt[maxn], ch[maxn * <span class="number">33</span>][<span class="number">2</span>], val[maxn * <span class="number">33</span>];</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> lst, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">28</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      val[o] = val[lst] + <span class="number">1</span>;  <span class="comment">//在原版本的基础上更新</span></span><br><span class="line">      <span class="keyword">if</span> ((v &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ch[o][<span class="number">0</span>]) ch[o][<span class="number">0</span>] = ++cnt;</span><br><span class="line">        ch[o][<span class="number">1</span>] = ch[lst][<span class="number">1</span>];</span><br><span class="line">        o = ch[o][<span class="number">0</span>];</span><br><span class="line">        lst = ch[lst][<span class="number">0</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ch[o][<span class="number">1</span>]) ch[o][<span class="number">1</span>] = ++cnt;</span><br><span class="line">        ch[o][<span class="number">0</span>] = ch[lst][<span class="number">0</span>];</span><br><span class="line">        o = ch[o][<span class="number">1</span>];</span><br><span class="line">        lst = ch[lst][<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val[o] = val[lst] + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// printf("%d\n",o);</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> o1, <span class="keyword">int</span> o2, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">28</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="comment">// printf("%d %d %d\n",o1,o2,val[o1]-val[o2]);</span></span><br><span class="line">      <span class="keyword">int</span> t = ((v &amp; (<span class="number">1</span> &lt;&lt; i)) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (val[ch[o1][!t]] - val[ch[o2][!t]])</span><br><span class="line">        ret += (<span class="number">1</span> &lt;&lt; i), o1 = ch[o1][!t], o2 = ch[o2][!t];  <span class="comment">//尽量向不同的地方跳</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        o1 = ch[o1][t], o2 = ch[o2][t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i), s[i] = s[i - <span class="number">1</span>] ^ a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    st.rt[i] = ++st.cnt, st.insert(st.rt[i], st.rt[i - <span class="number">1</span>], s[i]);</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;op);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">'A'</span>) &#123;</span><br><span class="line">      n++;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + n);</span><br><span class="line">      s[n] = s[n - <span class="number">1</span>] ^ a[n];</span><br><span class="line">      st.rt[n] = ++st.cnt;</span><br><span class="line">      st.insert(st.rt[n], st.rt[n - <span class="number">1</span>], s[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">'Q'</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line">      l--;</span><br><span class="line">      r--;</span><br><span class="line">      <span class="keyword">if</span> (l == r &amp;&amp; l == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s[n] ^ x);  <span class="comment">//记得处理 l=r=1 的情况</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, st.query(st.rt[r], st.rt[max(l - <span class="number">1</span>, <span class="number">0</span>)], x ^ s[n]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P4592-TJOI2018"><a href="#P4592-TJOI2018" class="headerlink" title="P4592 [TJOI2018]"></a>P4592 [TJOI2018]</h2><p>还有一个题是树上的查询，有两种查询方式，一种是在子树中选一个数与$x$异或最大，这个可以通过dfs序转成区间问题，还有一种路径查询的，思想和树上主席树一样</p><p><a href="https://www.luogu.org/problem/P4592" target="_blank" rel="noopener">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">600020</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> fa[maxn][<span class="number">20</span>],deep[maxn],vis[maxn];</span><br><span class="line"><span class="keyword">int</span> root_arr[maxn],root_tree[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lc,rc,cnt,val;</span><br><span class="line">&#125;T[maxn * <span class="number">32</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> root[maxn],head[maxn],tot,cnt,m,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">   edge[cnt].to = v;</span><br><span class="line">   edge[cnt].next = head[u];</span><br><span class="line">   head[u] = cnt ++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dsz;</span><br><span class="line"><span class="keyword">int</span> in[maxn],out[maxn],id[maxn],v[maxn];</span><br><span class="line"><span class="keyword">int</span> xxor[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep[u] &lt; deep[v])swap(u,v);</span><br><span class="line">    <span class="keyword">int</span> dis = deep[u] - deep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;dis)u = fa[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == v)<span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[u][i] != fa[v][i])&#123;</span><br><span class="line">            u = fa[u][i];</span><br><span class="line">            v = fa[v][i];            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> val,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">    x = ++tot;T[x] = T[y];T[x].cnt ++;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        T[x].val = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = (val &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!c)&#123;</span><br><span class="line">        update(T[y].lc,T[x].lc,val,k<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        update(T[y].rc,T[x].rc,val,k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[now] = <span class="literal">true</span>;</span><br><span class="line">    in[now] = ++dsz; </span><br><span class="line">    id[dsz] = now;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[now] &lt; (<span class="number">1</span>&lt;&lt;i))<span class="keyword">break</span>;</span><br><span class="line">        fa[now][i] = fa[fa[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];~i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[to])&#123;</span><br><span class="line">            fa[to][<span class="number">0</span>] = now;</span><br><span class="line">            deep[to] = deep[now] + <span class="number">1</span>;</span><br><span class="line">            update(root_tree[now],root_tree[to],v[to],K);</span><br><span class="line">            dfs(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out[now] = dsz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_arr</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> x,<span class="keyword">int</span> val,<span class="keyword">int</span> k,<span class="keyword">int</span> ret=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; y &lt;&lt; " " &lt;&lt; x &lt;&lt; " " &lt;&lt; val &lt;&lt; " " &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">0</span>)<span class="keyword">return</span> T[x].val ^ val;</span><br><span class="line">    <span class="keyword">int</span> c = (val &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(c)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = T[T[x].lc].cnt - T[T[y].lc].cnt;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)<span class="keyword">return</span> query_arr(T[y].lc,T[x].lc,val,k<span class="number">-1</span>,ret+(<span class="number">1</span>&lt;&lt;k));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query_arr(T[y].rc,T[x].rc,val,k<span class="number">-1</span>,ret);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = T[T[x].rc].cnt - T[T[y].rc].cnt;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)<span class="keyword">return</span> query_arr(T[y].rc,T[x].rc,val,k<span class="number">-1</span>,ret+(<span class="number">1</span>&lt;&lt;k));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query_arr(T[y].lc,T[x].lc,val,k<span class="number">-1</span>,ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_path</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> x,<span class="keyword">int</span> f,<span class="keyword">int</span> ff,<span class="keyword">int</span> val,<span class="keyword">int</span> k,<span class="keyword">int</span> ret=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">0</span>)&#123;<span class="keyword">return</span> ret;&#125;</span><br><span class="line">    <span class="keyword">int</span> c = (val &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(c)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = T[T[x].lc].cnt + T[T[y].lc].cnt - T[T[f].lc].cnt - T[T[ff].lc].cnt;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; k &lt;&lt; " left " &lt;&lt; cnt&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)<span class="keyword">return</span> query_path(T[y].lc,T[x].lc,T[f].lc,T[ff].lc,val,k<span class="number">-1</span>,ret+(<span class="number">1</span>&lt;&lt;k));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query_path(T[y].rc,T[x].rc,T[f].rc,T[ff].rc,val,k<span class="number">-1</span>,ret);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = T[T[x].rc].cnt + T[T[y].rc].cnt - T[T[f].rc].cnt - T[T[ff].rc].cnt;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; k &lt;&lt; " right " &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)<span class="keyword">return</span> query_path(T[y].rc,T[x].rc,T[f].rc,T[ff].rc,val,k<span class="number">-1</span>,ret+(<span class="number">1</span>&lt;&lt;k));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query_path(T[y].lc,T[x].lc,T[f].lc,T[ff].lc,val,k<span class="number">-1</span>,ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    x = ++tot;T[x].cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    build(T[x].lc,k<span class="number">-1</span>);</span><br><span class="line">    build(T[x].rc,k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m); </span><br><span class="line">   init(n);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v[i]);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">int</span> xx,yy;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;xx,&amp;yy);</span><br><span class="line">       addedge(xx,yy);addedge(yy,xx);</span><br><span class="line">   &#125;</span><br><span class="line">   update(root_tree[<span class="number">0</span>],root_tree[<span class="number">1</span>],v[<span class="number">1</span>],K);</span><br><span class="line">   dfs(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=dsz;i++)&#123;</span><br><span class="line">       xxor[i] =  v[id[i]];</span><br><span class="line">       update(root_arr[i<span class="number">-1</span>],root_arr[i],xxor[i],K);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> op,qx,qy,qz;</span><br><span class="line">   <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line">       <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;qx,&amp;qy);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query_arr(root_arr[in[qx] - <span class="number">1</span>] , root_arr[out[qx]],qy,K)); </span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;qx,&amp;qy,&amp;qz);</span><br><span class="line">           <span class="keyword">int</span> fx = lca(qx,qy);</span><br><span class="line">           <span class="keyword">int</span> ffx = fa[fx][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//    cout &lt;&lt; fx &lt;&lt; " " &lt;&lt; ffx &lt;&lt; endl;</span></span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query_path(root_tree[qx],root_tree[qy],root_tree[fx],root_tree[ffx],qz,K));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 数据结构 </category>
          
          <category> 可持久trie树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 可持久化trie树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xyw_xyw_2019年8月7日</title>
      <link href="/2019/08/06/xyw_day_20190807/"/>
      <url>/2019/08/06/xyw_day_20190807/</url>
      
        <content type="html"><![CDATA[<h1 id="xyw5vplus1-2019-08-07"><a href="#xyw5vplus1-2019-08-07" class="headerlink" title="xyw5vplus1_2019.08.07"></a>xyw5vplus1_2019.08.07</h1><p><em>一个人的七夕节……</em></p><p><em>手动@在家帮妈妈干活的另一位 @key</em></p><p>今天的上午又是一个迟到的上午，睡过头的我开始了在寝室的学习计划，</p><p>233矩阵题，“花式”构造矩阵，（其实也没有花式啦，就是正常地推就可以了，只是真的觉得矩阵有意思~</p><p>HDU 5646 把n拆成k个不同的正整数和，要求这k个正整数的积最大，</p><p>n,k&lt;=1e9</p><p>继续是纸老虎的数据范围，k实际有用的只有不到1e5，因为1+2+3+……+k&gt;n的情况就会无解</p><p>接下来一个事实是要使正数之间的乘积变得更大，增大最小的那个数是最优策略，（不等式计算一下即可得</p><p>那么就出现了我们需要把最小的数字最大化，二分！</p><p>写一个判断剩下部分能不能表示出来的bool函数这题就做完了。</p><p>上午借助洛谷成功地把森林补完了，总共犯了三个错误：</p><p>​    1.最蠢的，query的时候往右子树跑的时候k忘减cnt了，居然过了样例……</p><p>​    2.合并的时候忘记增加边了</p><p>​    3.也是最玄学的感觉，目前还没有理解，<strong><em>因为树的形态在改变，dfs的时候维护father数组的时候的上界不能使lg[dep[cur]]，而应该是最大的19，洛谷上有图文解释，还不明白为什么</em></strong></p><p>花神的嘲讽计划，迷之被卡Hash，居然看了别人的Discuss换成自然溢出就过了（黑人问号.jpg？</p><p>（一度又自己给自己出题，好在这题k是定值降低了难度，于是就引申出了另一道题 小清新人渣的本愿</p><p>直接不要害怕上bitset+Map就完事了，貌似加个快读是可以过的？莫队复杂度毕竟玄学……（其实我还并没有写过这题，怎么说的跟我真的过了一样的</p><p>洛谷上看了几个题，有些也不是主席树的，稍微回顾了一下莫队</p><p>然后就跟楚盟师哥一起开始看多校级别的主席树了</p><p>首先是今年第4场多校的主席树，能比较快地想出来还是蛮开心的，耶！ヽ(￣▽￣)ﾉ</p><p>关键在于想到二分，然后就转化成统计区间内的数落在某个值域范围内的数的个数</p><p>另外一道是16年的一道，一开始诈和了一个做法，（还在还是为之后的做法提供了一些方向的，意识到问题之后慢慢地还是调整过来了，最后也成功地想出来正解，总的思考时间大约在半个小时左右</p><p>嗯总体来说能想出这两道多校级别的主席树又给我和楚盟师哥增长了不少信心ヽ(￣▽￣)ﾉ</p><p>明天继续会朝着多校级别的主席树题的难度去进军的</p>]]></content>
      
      
      <categories>
          
          <category> xyw </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> xyw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cm_2019年8月6日</title>
      <link href="/2019/08/05/cm_day_20190806/"/>
      <url>/2019/08/05/cm_day_20190806/</url>
      
        <content type="html"><![CDATA[<h1 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h1><p>醒来才看到新微博，hhh的某个歌手搞了个大新闻，当时还是挺震惊的，原来2019年了，也仍然会有人对自己这么狠。只是希望中国说唱圈不会再被这种事件拖后腿，哎。</p><p>复习了一下ac自动机，学习了一下fail树，还是很有收获的，仿佛对于子串的理解又更深刻了一些？主要目的是为了做那道 <strong>ac自动机fail树dfs序建可持久化线段树</strong> 的题</p><a id="more"></a><h1 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h1><p>终于那道ac自动机+主席树的题过了，md传参的时候又又又又又写错变量了，我就是个智障。</p><p>顺便看了几个主席树的题，都还蛮不错的。</p><p>明天下午决定学一学平衡树，顺便补一个需要用到这个和主席树的题。</p><p>奶茶真好喝，嗝~</p><h1 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h1><p>今天日报比较短，因为主要是把时间拿来写学习笔记了，晚上学了学可持久化trie树，感觉收获也很多，明天早上打算再看两个这道题</p><p>对了，祝大家明天七夕快乐！</p>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> cm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cm_Fail树学习笔记 &amp;&amp; CodeForces 547E 题解</title>
      <link href="/2019/08/05/learn_fail_CodeForces547E/"/>
      <url>/2019/08/05/learn_fail_CodeForces547E/</url>
      
        <content type="html"><![CDATA[<h1 id="cm-Fail树学习笔记-amp-amp-CodeForces-547E-题解（ac自动机fail树dfs序建可持久化线段树）"><a href="#cm-Fail树学习笔记-amp-amp-CodeForces-547E-题解（ac自动机fail树dfs序建可持久化线段树）" class="headerlink" title="cm_Fail树学习笔记 &amp;&amp; CodeForces 547E  题解（ac自动机fail树dfs序建可持久化线段树）"></a>cm_Fail树学习笔记 &amp;&amp; CodeForces 547E  题解（ac自动机fail树dfs序建可持久化线段树）</h1><p><em>每天都能学到新的知识，这种感觉还是很棒的！</em></p><p><em>说起来，今天学习fail树的应用，还是因为在做主席树专题的时候碰到了一个字符串的题</em></p><p><em>听说这一套流程已经成梗了，希望有空能把下图右半边也学会</em></p><a id="more"></a><p><img src="https://raw.githubusercontent.com/DcmTruman/DcmTruman.github.io/images/img1_2019-08-06.jpeg" alt="%%%%%"></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给你$n$个字符串，长度之和小于$2\times 10^{5}$，现在有$5\times 10^{5}$个询问$i,j,k$,问你，在第$i$个字符串到第$j$个字符串中，第$k$个字符串出现了多少次。</p><p><a href="https://codeforces.com/problemset/problem/547/E" target="_blank" rel="noopener">原题链接</a></p><h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2><ul><li>可持久化线段树</li><li>ac自动机</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>因为是<strong>学习笔记</strong>，所以我们先复习和学习一下关于ac自动机和fail树的知识点。</p><h3 id="ac自动机"><a href="#ac自动机" class="headerlink" title="ac自动机"></a>ac自动机</h3><p>熟悉kmp的同学都知道，在kmp中，存在一个next数组，<code>next[i]</code>表示的是到当前匹配串<code>i</code>的位置的字符串中，最长的<strong>前缀与后缀相等的串</strong>，kmp中之所以这么做，是因为一旦失配，可以减少一定的匹配次数。</p><p>同理ac自动机，<strong>fail指针所指向的节点，表示的是走到当前节点所代表的字符串中，与其某个后缀相同的最长的前缀在trie树上的位置。</strong></p><p>说到这里就要说一句我觉得一些子串问题的本质思想–<strong>子串是某个后缀的前缀，或者某个前缀的后缀</strong>。虽然听起来有点废话，但对我这种菜鸡来说，一旦用前后缀的思想去想，有些问题就会有些眉目了。</p><h3 id="fail树"><a href="#fail树" class="headerlink" title="fail树"></a>fail树</h3><p>现在有个问题，如何统计模式串x在模式串y中出现的次数呢？要统计次数，说明我们要找到x在哪些地方是y的子串。按照上面的思想，我们需要找到，在y的所有前缀中，哪些的后缀是x在trie对应的位置？</p><p>暴力做法是，我们沿着y在trie中往下走，每到一个节点，我们就沿着fail一直跳到根，如果过程中走到x所在的位置，说明存在一个y的前缀，其后缀等于x。但是很暴力啊，每个位置都要沿着fail树跳到根啊！不优雅啊！</p><p>那么我们可以想到这么一件事，fail指针在每个节点下，是唯一的。我们是不是可以反向建一棵树？通过y走到当前节点now，沿着fail往上跳，也就是在树中从孩子往父亲跳。如果最终跳到了字符串x所代表的的节点，那么说明now在fail树中的节点必然是以x在fail树的节点为根的子树中。所以我们计算孩子对祖先的贡献，只需要沿着y走的时候，把每个节点在fail树中对应的节点+1，然后计算x对应节点子树的权值之和即可！</p><h3 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h3><p>是不是听起来很酷？但是，有询问啊，针对不同区间的询问，我们加的权值也不一样，回答完后还要把他们恢复，避免互相干扰，怎么办？一种做法，离线。但是为了练习可持久化线段树，我偏不离线！</p><p>子树这种可以dfs序拆成区间的东西和<strong>权值和</strong>这种可减东西，让然可以用可持久化线段树维护啊！</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>那么，这道题的题解就出来了，ac自动机fail树dfs序建可持久化线段树</p><ol><li>先把所有串放在ac自动机中，build一下，我们得到了fail指针。</li><li>根据fail指针反向建树，我们得到了一颗fail树。</li><li>遍历n个串。对于每个串，我们会树中修改<code>strlan(n)</code>个点，使得树中的点权值+1，为了快速获得一颗子树的权值和，我们先将树dfs，拆成一个个的区间，然后就是类似于线段树单点修改、区间查和的操作了。</li><li>在这个基础上，每次线段树一个点发生变化，我们都新开一个根节点，新增$logn$个节点，基本思想和主席树类似，<code>strlan(n)</code>个点修改，就不断更新<code>root[now]</code>。</li><li>然后查区间和，也是<code>root[r]</code>的树对应的区间和减去<code>root[l-1]</code>树对应的区间和，即可，这样，我们就能快速求得在插入i~j个字符串后，fail树上k节点的子树的权值和，即子串出现的次数。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>有点丑。期间还把<code>r</code>和<code>R</code>搞错了，一直在T第十个样例，我好蠢。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc1(a) scanf(<span class="meta-string">"%lld"</span>,&amp;a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc2(a,b) scanf(<span class="meta-string">"%lld %lld"</span>,&amp;a,&amp;b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fuck(x) cout&lt;&lt;<span class="meta-string">"[Debug : "</span>&lt;&lt;#x&lt;&lt;<span class="meta-string">" "</span>&lt;&lt;(x)&lt;&lt;<span class="meta-string">']'</span>&lt;&lt;endl</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn_tot=<span class="number">200000</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxq = <span class="number">200020</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn_tot],cnt;</span><br><span class="line"><span class="keyword">char</span> s[maxn_tot*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ss[maxq];</span><br><span class="line"><span class="keyword">int</span> ans[maxq];</span><br><span class="line"><span class="keyword">int</span> in[maxn_tot],out[maxn_tot];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn_tot];</span><br><span class="line"><span class="keyword">int</span> n,m,tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].v=v;</span><br><span class="line">    edge[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ac</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> nxt[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> fail,cnt;</span><br><span class="line">    &#125;stable[maxn_tot];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;maxn_tot;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">26</span>;j++)stable[i].nxt[j]=<span class="number">0</span>;</span><br><span class="line">            stable[i].fail = stable[i].cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//head[i] = </span></span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> kk)</span></span>&#123;</span><br><span class="line">        <span class="comment">// printf("nows=%s\n",s);</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="comment">//cout &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(!stable[now].nxt[c-<span class="string">'a'</span>])stable[now].nxt[c-<span class="string">'a'</span>]=size++;</span><br><span class="line">            now = stable[now].nxt[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[kk] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stable[<span class="number">0</span>].fail = <span class="number">-1</span>;</span><br><span class="line">        q.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stable[u].nxt[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(u == <span class="number">0</span>)&#123;</span><br><span class="line">                        stable[stable[u].nxt[i]].fail=<span class="number">0</span>;</span><br><span class="line">                        addedge(<span class="number">0</span>,stable[u].nxt[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">int</span> v = stable[u].fail;</span><br><span class="line">                        <span class="keyword">while</span>(v!=<span class="number">-1</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(stable[v].nxt[i])&#123;</span><br><span class="line">                                stable[stable[u].nxt[i]].fail=stable[v].nxt[i];</span><br><span class="line">                                addedge(stable[v].nxt[i],stable[u].nxt[i]);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                v = stable[v].fail;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(v == <span class="number">-1</span>)&#123;</span><br><span class="line">                            stable[stable[u].nxt[i]].fail = <span class="number">0</span>;</span><br><span class="line">                            addedge(<span class="number">0</span>,stable[u].nxt[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    q.push(stable[u].nxt[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ac.init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;maxn_tot;i++)head[i] = <span class="number">-1</span>;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dsz = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// fuck(now);</span></span><br><span class="line">    <span class="comment">// fuck(f);</span></span><br><span class="line">    in[now]=++dsz;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];~i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>(to != f)dfs(to,now);</span><br><span class="line">    &#125;</span><br><span class="line">    out[now]=dsz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lc,rc,sum;</span><br><span class="line">&#125;T[maxq*<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; tot &lt;&lt; endl;</span></span><br><span class="line">    x=++tot;T[x].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(T[x].lc,l,mid);</span><br><span class="line">    build(T[x].rc,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = ++tot;T[x] = T[y];</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        T[x].sum += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid &gt;= pos)update(T[y].lc,T[x].lc,l,mid,pos,val);</span><br><span class="line">    <span class="keyword">else</span> update(T[y].rc,T[x].rc,mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">    T[x].sum = T[T[x].lc].sum + T[T[x].rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l &amp;&amp; r&lt;=R)<span class="keyword">return</span> T[x].sum - T[y].sum;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid )ret += query(T[y].lc,T[x].lc,l,mid,L,R);</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; R)ret += query(T[y].rc,T[x].rc,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upup</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> &amp;x,<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// printf("%s\n",s);</span></span><br><span class="line">    x=++tot;T[x]=T[y];</span><br><span class="line">    <span class="keyword">int</span> ln = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;ln;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[i];</span><br><span class="line">        <span class="keyword">int</span> nxt = ac.stable[now].nxt[c-<span class="string">'a'</span>];</span><br><span class="line">        <span class="comment">// fuck(nxt);</span></span><br><span class="line">        <span class="comment">// fuck(in[nxt]);</span></span><br><span class="line">        update(x,x,<span class="number">1</span>,dsz,in[nxt],<span class="number">1</span>);</span><br><span class="line">        now = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> nowl,<span class="keyword">int</span> nowr,<span class="keyword">int</span> nowk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ac_id = ans[nowk];</span><br><span class="line">    <span class="keyword">int</span> l = in[ac_id];</span><br><span class="line">    <span class="keyword">int</span> r = out[ac_id];</span><br><span class="line">    <span class="keyword">return</span> query(root[nowl<span class="number">-1</span>],root[nowr],<span class="number">1</span>,dsz,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;maxn;i++)s[i] = <span class="string">'\0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ss[i] = ss[i<span class="number">-1</span>] + <span class="built_in">strlen</span>(s + ss[i<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+ss[i]);</span><br><span class="line">        ac.ins(s + ss[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    ac.build();</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        upup(root[i<span class="number">-1</span>],root[i],s+ss[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> aa,bb,kk;<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;aa,&amp;bb,&amp;kk);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve(aa,bb,kk));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 字符串 </category>
          
          <category> ac自动机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 主席树 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> ac自动机 </tag>
            
            <tag> fail树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xyw_2019年8月6日</title>
      <link href="/2019/08/05/xyw_day_20190806/"/>
      <url>/2019/08/05/xyw_day_20190806/</url>
      
        <content type="html"><![CDATA[<h1 id="xyw5vplus1-2019-08-06"><a href="#xyw5vplus1-2019-08-06" class="headerlink" title="xyw5vplus1_2019.08.06"></a>xyw5vplus1_2019.08.06</h1><p>好吧，迟到一天的总结，昨天晚上太懒了……</p><p>下面就以昨天的视角来回顾一下，</p><p>嗯，今天，上午我看了矩阵快速幂的一些题目，</p><p>并不是很裸，感觉学到了不少东西</p><p>首先是 HDU4965  14年多校的题，这题耍了点小Trick，朴素计算A * B的话矩阵的长度会过大导致T掉，为了加速计算，利用矩阵的结合律，先计算B * A的话就能使矩阵的长度变小，然后保证了矩阵快速幂的复杂度。</p><p>果然文化课还是有用的（在认真听课的情况下</p><p>几道UVA的水题就不说了，</p><p>接下来介绍非常经典的一道题（立个Flag，周末写那道题的题解</p><p>POJ 3735  </p><p>非常经典的<strong>把各种操作看成转移矩阵</strong>的Trick</p><p>以及我个人理解的<strong>用类似供货的角度去考虑转移的角度，置0就是把各种供货源都切断</strong>，</p><p>这道题让我真的感觉<strong>在线性空间内，一切皆矩阵</strong>。</p><p><strong>任何线性的变化都可以表示成一个转移矩阵</strong></p><p>一堆操作就是不断地左乘转移矩阵，各种什么神奇的变换只要是线性的转移就一定能构造出一个矩阵，各种非常花式的都可以</p><p>甚至头脑风暴了一下，<strong>感觉平时每个人的学习在线性模型下也都可以看成是一个转移矩阵，每个人的能力值构成一个向量</strong>，</p><p>随着时间的流逝，每个人会从别人地方学到一些知识，自己在上一个时间点的知识也会有大部分转移过来，并且自己也会有一些从原有知识得到的新的知识，这样的一个线性组合<strong>构成了下一个时间点的知识来源</strong>。</p><p>嗯，就当是在瞎BB吧，但感觉仿佛打开了一扇新世界的大门，</p><p>HDU 5607 Graph 那题，明白题解为什么是对的，<strong><em>但是想不太清楚自己的为什么错了？？？</em></strong></p><p>下午的时候跟楚盟师哥一起看了一些再难一点的主席树的题，感觉对主席树的应用能力得到了提高，</p><p>熟悉了几种基本的应用场景之后想题更加能抓住重点了，写题的时候真的感觉有把握多了，调试起来也更加有心得了，已经把两个树上的模型整理到了板子里面去。</p><p>下午写了几个相对挺裸的题，其中有一个是今年南昌邀请赛上的树上主席树的题，</p><p>想的三个较难的题分别是ZOJ 4053 ，去年青岛网络赛的一个题；HDU 6287 2018女生赛；HDU 6601 今天多校第二场</p><p>第一个题确实不太会做，但感觉一点头绪都没有确实不应该，感觉询问的东西比较难求就直接放弃了，然而其实只需要不断维护然后传递下去就可以了，真正的难点在于拆分一段的时候怎么快速得到剩下两段，</p><p>这个时候<strong>启发式</strong>就登场了，解决看起来很困难的问题的“类暴力”做法，虽然看起来low但就是应用起来非常牛逼啊，暴力地跑，然后边跑边查询的时候顺便用一下主席树。<strong>必补の题！！！</strong></p><p>第二个题我们想到了思路，分解质因数之后维护一下就可以了。</p><p>第三个题我们有一个不同于题解的分治做法，还没有实现，也是<strong>必补の题！！！</strong></p><p>我们的复杂度是O(nlog^2n)的，标答的做法是O(44nlogn)的，我觉得半斤对八两吧（如果我们的做法确实是可行的话</p><p>给定一个数列，问区间内选三个数能构造的周长最大的三角形是多长。</p><p>首先楚盟师哥给出一个事实是满足最优的情况一定是三条边按长度大小连续的，</p><p>于是乎我们想到了分治，要么全在左边取，要么全在右边取，要么取中间分界线上取连续的三个。</p><p>而题解意识到<strong>构不成三角形的最极端的情况是斐波那契数列</strong>，（很熟悉有没有？中山大学校赛！</p><p>那么因为数据范围ai&lt;=1e9，所以最多查询44次就OK了，每次查询的话询问第k大，第k+1大和第k+2大能否构成三角形，k从小到大枚举。</p><p>这道题（包括上次中山大学的校赛）给我们一个很深刻的启发是<strong>某些数据范围其实看得很吓人但是都是纸老虎而已</strong>，然后<strong>构成三角形的题要多考虑考虑斐波那契数列</strong>，然后利用它<strong>指数级的增长去做一些看起来很plain但是却很有效的事情。</strong></p><p>最后晚上写了森林那道题，RE到自闭（好在今天（真正的今天）成功解决了</p><p>同样是启发式的思路，非常漂亮，<strong>重建主席树！！！</strong>当然有一些小细节是不太能处理好的，这个我们留到下回再讲。</p>]]></content>
      
      
      <categories>
          
          <category> xyw </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> xyw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cm_2019年8月5日</title>
      <link href="/2019/08/04/cm_day_20190805/"/>
      <url>/2019/08/04/cm_day_20190805/</url>
      
        <content type="html"><![CDATA[<h1 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h1><p>今天早上看了一下网络流中，上下界的费用流的建图原理，大概明白了一些，还是非常巧妙的，想改天专门写个学习笔记来记录一下。顺便也更新一下自己的板子。</p><p>上午洗澡的时候，想到那道ac自动机 + fail树dfs序 + 主席树的题，越想越觉得有意思，于是到603第一件事就是重新看了一下ac自动机这些东西，不出意外的话，明后天想把这道题搞懂然后做一下。</p><a id="more"></a><h1 id="下午-amp-晚上"><a href="#下午-amp-晚上" class="headerlink" title="下午&amp;晚上"></a>下午&amp;晚上</h1><p>其实，下午主要干的两件事就是学习了动态主席树，第一次感受到了树套树的威力，然后做了一道可持久化并查集的题，也算是模板题吧。</p><p>树套树那道题，感觉自己对空间复杂度还是算不太好，一开始总是<strong>越界或者超内存</strong>，而且感觉这种空间复杂度比较大的题，我总是会栽在这上面…以后开数组空间，还是不要随心所欲的开，交也不要过了样例就交。</p><p>并查集那个题…传参的时候<strong>又把左右孩子写错了</strong>，好蠢。</p><p>顺便写了一下这道题学习笔记和题解，感觉自己重新梳理一遍确实会更清晰。</p><p>然后还知道了一件事，博客如果不去搜索引擎里折腾一下，别人是没办法通过google找到你的…知识当然是分享才会更有意思啊，于是就去search console里搞了一下，百度的爬虫对github pages好像不太友好，改天试试注册个自己的域名试试能不能爬。</p><hr><p>晚上看了一个关于最近的《哪吒》和国产动画历史的分析，还是挺感动的，也实在充满了期待。</p><p>几十年前一直石猴大闹天宫，开辟了国产动画的新天地，几十年后一只猴子归来，又给整个市场注入活力</p><p>这里是视频地址</p><p><a href="https://www.bilibili.com/video/av62353199" target="_blank" rel="noopener">揭开中国动画业60年的神预言！封神宇宙全解析(bilibili)</a></p>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> cm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cm_动态主席树学习笔记 &amp; ZOJ 2112题解</title>
      <link href="/2019/08/04/cm_learn_dynamicchariman/"/>
      <url>/2019/08/04/cm_learn_dynamicchariman/</url>
      
        <content type="html"><![CDATA[<h1 id="cm-动态主席树学习笔记-amp-ZOJ-2112题解"><a href="#cm-动态主席树学习笔记-amp-ZOJ-2112题解" class="headerlink" title="cm_动态主席树学习笔记 &amp; ZOJ 2112题解"></a>cm_动态主席树学习笔记 &amp; ZOJ 2112题解</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给你一个长度为$n$的序列$a_{1},a_{2}…a_{n}$，$m$个询问，有两种操作</p><ol><li>查询区间第k大</li><li>把某个位置的值改成某个值</li></ol><p>$0&lt;n\leq 50000,0&lt;m\leq 10000,a_{i}\leq 1000000000$</p><a id="more"></a><h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2><ul><li>静态主席树查区间第k大</li><li>树状数组</li></ul><h2 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h2><p>如果知道学过主席树，想必「区间查询第k大」大家并不陌生，对于静态区间第k大的问题，我们可以按照下标依次从小到大建立<strong>可持久化的权值线段树</strong>，线段树底层的点，表示的是这个数在区间[1,i]出现的次数，属于一种前缀。由于「次数」这种东西是可减的，所以如果我们想知道[l,r]的权值分布情况，只需要用<strong>r</strong>节点的线段树减去<strong>l-1</strong>节点的线段树即可</p><h2 id="动态主席树"><a href="#动态主席树" class="headerlink" title="动态主席树"></a>动态主席树</h2><p>然后考虑，修个一个节点，会产生什么影响呢？</p><p>由于，主席树是统计前缀信息，每个新的树都要依赖前一颗，每当某个位置$i$的权值的数量被修改，那么$[i,n]$对应的所有树都要被修改，但时间上不允许我们这么搞，所以要想个更优雅的办法，单点修改，区间查询，有没有什么想法？</p><p>首先我们对于原数组建一个传统线段树，然后，为了维护修改信息我们可以再建一个树状数组，数组的每个值代表的一颗权值线段树，每当一个点被修改，我只新增$log_{2}n$颗树，每颗树值新增$log_{2}n$个节点。查询的时候，只需要先在原主席树查到当前节点的权值sum，然后在加上修改后的影响。那么这个影响怎么查呢，我根据我的代码来讲。</p><p>首先根据原数组建主席树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  update(root[i<span class="number">-1</span>],root[i],<span class="number">1</span>,sz,getid(arr[i]),<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>c[i]</code>数组记录的是发生修改后的权值线段树的根节点，如果某个点$i$数值发生变化，我们<strong>不会暴力的修改$i~n$的每颗权值线段树，而是利用类似树状数组的思想，只修改部分权值线段树</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_a</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> pos,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">        update(c[i],c[i],<span class="number">1</span>,sz,pos,x);</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询的时候，先把改变的值对应的一些线段树的根节点找到，每次递归计算sum的时候，在原数列的值上加上修改后的影响,具体操作看下方完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc1(a) scanf(<span class="meta-string">"%lld"</span>,&amp;a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc2(a,b) scanf(<span class="meta-string">"%lld %lld"</span>,&amp;a,&amp;b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fuck(x) cout&lt;&lt;<span class="meta-string">"[Debug : "</span>&lt;&lt;#x&lt;&lt;<span class="meta-string">" "</span>&lt;&lt;(x)&lt;&lt;<span class="meta-string">']'</span>&lt;&lt;endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2500010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vv;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (<span class="keyword">int</span>)(lower_bound(vv.begin(),vv.end(),x)-vv.begin())+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum;</span><br><span class="line">&#125;T[maxm];</span><br><span class="line"><span class="keyword">int</span> m,tot,n,sz;</span><br><span class="line"><span class="keyword">int</span> root[maxn];</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> c[maxn],a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=++tot;</span><br><span class="line">    T[x].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(T[x].l,l,mid);</span><br><span class="line">    build(T[x].r,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> vl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=++tot;T[x]=T[y];</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        T[x].sum += vl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid &gt;= pos)update(T[y].l,T[x].l,l,mid,pos,vl);</span><br><span class="line">    <span class="keyword">else</span> update(T[y].r,T[x].r,mid+<span class="number">1</span>,r,pos,vl);</span><br><span class="line">    T[x].sum = T[T[x].l].sum + T[T[x].r].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_ta</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n;i++)c[i] = root[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_a</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> pos,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">        update(c[i],c[i],<span class="number">1</span>,sz,pos,x);</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> aa[maxn],cnt;</span><br><span class="line"><span class="keyword">int</span> bb[maxn],cnt2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        aa[cnt] = c[x];</span><br><span class="line">        cnt ++;</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(y &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        bb[cnt2] = c[y];</span><br><span class="line">        cnt2 ++;</span><br><span class="line">        y -= lowbit(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = T[T[x].l].sum - T[T[y].l].sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">        tmp -= T[T[aa[i]].l].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt2;i++)&#123;</span><br><span class="line">        tmp += T[T[bb[i]].l].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp &gt;= k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            aa[i] = T[aa[i]].l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt2;i++)&#123;</span><br><span class="line">            bb[i] = T[bb[i]].l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> query(T[y].l,T[x].l,l,mid,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            aa[i] = T[aa[i]].r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt2;i++)&#123;</span><br><span class="line">            bb[i] = T[bb[i]].r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> query(T[y].r,T[x].r,mid+<span class="number">1</span>,r,k-tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">&#125;qs[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        vv.clear();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;arr[i]);</span><br><span class="line">            vv.push_back(arr[i]);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c;<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;qs[i].i,&amp;qs[i].j,&amp;qs[i].k);</span><br><span class="line">                qs[i].type = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;qs[i].i,&amp;qs[i].k);</span><br><span class="line">                vv.push_back(qs[i].k);</span><br><span class="line">                qs[i].type = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(vv.begin(),vv.end());</span><br><span class="line">        vv.erase(unique(vv.begin(),vv.end()),vv.end());</span><br><span class="line">        sz = vv.size();</span><br><span class="line">        build(root[<span class="number">0</span>],<span class="number">1</span>,sz);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            update(root[i<span class="number">-1</span>],root[i],<span class="number">1</span>,sz,getid(arr[i]),<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        init_ta();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!qs[i].type)&#123;</span><br><span class="line">                getsum(qs[i].i<span class="number">-1</span>,qs[i].j);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,vv[query(root[qs[i].i<span class="number">-1</span>],root[qs[i].j],<span class="number">1</span>,sz,qs[i].k) - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                update_a(qs[i].i,getid(arr[qs[i].i]),<span class="number">-1</span>);</span><br><span class="line">                arr[qs[i].i] = qs[i].k;</span><br><span class="line">                update_a(qs[i].i,getid(arr[qs[i].i]),<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>对了，这道题要注意一下范围，因为要提前存好所有询问在离散化，所以同时也要考虑询问时那些修改的值的数量。</p>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 数据结构 </category>
          
          <category> 主席树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 主席树 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cm_可持久化并查集学习笔记 &amp;&amp; BZOJ 3657 题解</title>
      <link href="/2019/08/04/cm_learn_union_iijq/"/>
      <url>/2019/08/04/cm_learn_union_iijq/</url>
      
        <content type="html"><![CDATA[<h1 id="cm-可持久化并查集学习笔记-amp-amp-BZOJ-3657-题解"><a href="#cm-可持久化并查集学习笔记-amp-amp-BZOJ-3657-题解" class="headerlink" title="cm_可持久化并查集学习笔记 &amp;&amp; BZOJ 3657 题解"></a>cm_可持久化并查集学习笔记 &amp;&amp; BZOJ 3657 题解</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给你$n$个集合$1,2,…n$，要求支持下面一些操作</p><ul><li><p>合并$a$和$b$所在的集合</p></li><li><p>回到第$k$次操作之后的状态(查询算作操作）</p></li><li><p>询问$a$和$b$是否在同一集合</p><a id="more"></a><h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2></li><li><p>并查集</p></li><li><p>主席树</p></li></ul><h2 id="可持久化并查集"><a href="#可持久化并查集" class="headerlink" title="可持久化并查集"></a>可持久化并查集</h2><p>简单来说，这道题就是，并查集的询问集合以及合并的操作，但是要求你能回退到k次操作状态之后。所以我们必须要记录历史版本信息。</p><p>首先，先考虑，并查集的<code>merge</code>和<code>find</code>操作，实际上是改变了<code>father</code>数组，但是如果每次改变，我们都重新拷贝一次数组的话，空间就很爆炸，那么我们可以用<strong>可持久化线段树的思想</strong>。数组中每次某个位置节点发生改变，就新生成一个根节点，增加 $log_{2}n$个节点。而在取得时候，我们也不会像原来那样直接取father数组里拿，而是指定一个表示当前状态的根节点，$log_{2}$ 的查询到叶子节点，这两步我写成了<code>getfa</code>和<code>setfa</code>函数，其中<code>update</code>和<code>query</code>基本就是<strong>可持久化线段树</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(x,<span class="number">1</span>,n,now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setfa</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   update(x,tmp,<span class="number">1</span>,n,pos,val);</span><br><span class="line">   <span class="keyword">return</span> tmp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，线段树中，除了叶子节点以外的节点，是不存储额外信息的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=++tot;T[x]=T[y];</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        T[x].val = val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)update(T[y].l,T[x].l,l,mid,pos,val);</span><br><span class="line">    <span class="keyword">else</span> update(T[y].r,T[x].r,mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体代码比较简单好理解，就是在<code>find</code>和<code>merge</code>中，将原来函数中<strong>数组取值father</strong>和<strong>改变数组值</strong>变成现在在线段树上操作<code>getfa</code>和<code>setfa</code>。基本可以当板子来用了。</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc1(a) scanf(<span class="meta-string">"%lld"</span>,&amp;a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc2(a,b) scanf(<span class="meta-string">"%lld %lld"</span>,&amp;a,&amp;b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fuck(x) cout&lt;&lt;<span class="meta-string">"[Debug : "</span>&lt;&lt;#x&lt;&lt;<span class="meta-string">" "</span>&lt;&lt;(x)&lt;&lt;<span class="meta-string">']'</span>&lt;&lt;endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2500010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vv;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (<span class="keyword">int</span>)(lower_bound(vv.begin(),vv.end(),x)-vv.begin())+<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,val;</span><br><span class="line">&#125;T[maxn * <span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> tot,m,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=++tot;T[x].val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;T[x].val = l;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(T[x].l,l,mid);</span><br><span class="line">    build(T[x].r,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=++tot;T[x]=T[y];</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        T[x].val = val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)update(T[y].l,T[x].l,l,mid,pos,val);</span><br><span class="line">    <span class="keyword">else</span> update(T[y].r,T[x].r,mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> T[x].val;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid &gt;= pos)<span class="keyword">return</span> query(T[x].l,l,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(T[x].r,mid+<span class="number">1</span>,r,pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> opt[maxn];</span><br><span class="line"><span class="keyword">int</span> aa,bb,kk;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(x,<span class="number">1</span>,n,now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setfa</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   update(x,tmp,<span class="number">1</span>,n,pos,val);</span><br><span class="line">   <span class="keyword">return</span> tmp; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> &amp;rt,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// fuck(x);</span></span><br><span class="line">    <span class="keyword">int</span> fx = getfa(rt,x);</span><br><span class="line">    <span class="keyword">if</span>(fx == x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fx = find(rt,fx);</span><br><span class="line">        <span class="comment">// fuck(x);</span></span><br><span class="line">        <span class="comment">// fuck(fx);</span></span><br><span class="line">        rt = setfa(rt,x,fx);</span><br><span class="line">        <span class="keyword">return</span> fx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;rt,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(rt,x);</span><br><span class="line">    <span class="keyword">int</span> fy = find(rt,y);</span><br><span class="line">    <span class="keyword">if</span>(fx != fy)&#123;</span><br><span class="line">        rt = setfa(rt,fx,fy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    n ++;</span><br><span class="line">    <span class="comment">//for(int i = 1;i&lt;=n;i++)scanf()</span></span><br><span class="line">    build(opt[<span class="number">0</span>],<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">int</span> lastans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        opt[i] = opt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> oo;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;oo);</span><br><span class="line">        <span class="keyword">if</span>(oo == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;aa,&amp;bb);</span><br><span class="line">            aa = aa ^ lastans;</span><br><span class="line">            bb = bb ^ lastans;</span><br><span class="line">            aa ++;bb ++;</span><br><span class="line">            <span class="comment">// fuck(aa);fuck(bb);</span></span><br><span class="line">            merge(opt[i],aa,bb);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( oo == <span class="number">2</span> )&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;kk);</span><br><span class="line">            kk = kk ^ lastans;</span><br><span class="line">            <span class="comment">// fuck(kk);</span></span><br><span class="line">            opt[i] = opt[kk];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;aa,&amp;bb);</span><br><span class="line">            aa = aa ^ lastans;</span><br><span class="line">            bb = bb ^ lastans;</span><br><span class="line">            aa ++;</span><br><span class="line">            bb ++;</span><br><span class="line">            <span class="keyword">int</span> fx = find(opt[i],aa);</span><br><span class="line">            <span class="keyword">int</span> fy = find(opt[i],bb);</span><br><span class="line">            <span class="comment">// fuck(aa);fuck(bb);</span></span><br><span class="line">            <span class="comment">// fuck(fx);fuck(fy);</span></span><br><span class="line">            <span class="keyword">if</span>(fx == fy)lastans = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> lastans = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lastans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 数据结构 </category>
          
          <category> 主席树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 主席树 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 可持久化线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xyw_2019年8月5日</title>
      <link href="/2019/08/04/xyw_day_20190805/"/>
      <url>/2019/08/04/xyw_day_20190805/</url>
      
        <content type="html"><![CDATA[<h1 id="xyw5vplus1-2019-08-05"><a href="#xyw5vplus1-2019-08-05" class="headerlink" title="xyw5vplus1_2019.08.05"></a>xyw5vplus1_2019.08.05</h1><p>今天上午，在做一些矩阵快速幂有关的题目，总体来说做的比较顺畅，</p><p>基本就是构造出一个转移矩阵的事情，</p><p>然后解决了矩阵快速幂的板子在使用的时候的问题，</p><p>也明白了转移的时候多一些常数该如何处理，多增加一维就可以了</p><p>去年多校的数列分块+矩阵快速幂的题也补完了，感觉还是挺棒的题</p><a id="more"></a><p>中间T了两次都是因为<strong>快速幂的指数出现了负数然后就死循环了</strong>，</p><p>也补完了Comet OJ 欢乐赛 鸡尾酒出的那个飞行棋的题</p><p>挺好玩的一个题，结论也挺巧妙的，有点反常识，其实还是信心的问题，问题想清楚了倒确实不难。</p><p>下午开始继续学主席树，今天开始正式上手写主席树了，开始转向递归写法，牺牲一些速度，换来一些理解上的便捷对初学的我应该还是值得的，基本框架已经理清楚了，基本上就是每道题换一换维护的信息和pushup函数的事情，今天过了人生中的第2道和第3道主席树的题</p><p>感觉今天整体做题比较顺畅，即使卡题也都还比较有耐心，希望明天能继续保持这个状态。</p><p>明天会继续做一些有难度一点的矩阵快速幂的题，然后继续写一些已经讨论出做法的主席树的题</p><p>可能这周会开可持久化Trie树的学习</p>]]></content>
      
      
      <categories>
          
          <category> xyw </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> xyw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3181解题报告</title>
      <link href="/2019/08/03/POJ%203181/"/>
      <url>/2019/08/03/POJ%203181/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-3181解题报告"><a href="#POJ-3181解题报告" class="headerlink" title="POJ 3181解题报告"></a>POJ 3181解题报告</h1><p>题意很简单，</p><p>给你一个n，问你有多少种方案去把n用不超过k的正整数表示出来</p><p>1&lt;=n&lt;=1000 1&lt;=k&lt;=100</p><p>做法其实也很简单，</p><a id="more"></a><p>设dp [i] [j]表示 用不超过j的正整数表示i的方案数</p><p>那么分两种情况讨论，</p><p>当最大值是j的时候，有dp [i] [j] 从 dp [i-j] [j] 转移过来</p><p>当最大值小于j的时候  dp [i] [j] 从 dp [i] [j-1] 转移过来</p><p>（其实这是一个完全背包计数问题，居然没有看出来(；´д｀)ゞ 还好不影响做题</p><p>然而这题最大的坑点就在于没有取模，所以答案会超过long long 的范围，</p><p>（我会贴高精度的板子！</p><p>然而，你的高精度会T，至少C++的是这样，那么我觉得是不是Python和Java就更不用想了</p><p>牛逼网友们给了一个神奇的做法，<strong>用两个long long 去存储一个不超过二进制下 128 位的数，即第一个表示高64位，第二个表示低64位，然后分别转移</strong></p><p>（貌似就这样实现了一个__int 128  ???  </p><p>不过这种做法当然也有限制条件了，感觉在单纯处理只是加法和乘法的转移可以代替__int 128，然而出现减法就已经有点麻烦了，更不要说出现除法了</p><p>最后贴上丑陋的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxk=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line">ll dp1[maxn+<span class="number">5</span>][maxk+<span class="number">5</span>],dp2[maxn+<span class="number">5</span>][maxn+<span class="number">5</span>];</span><br><span class="line">ll mod=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">18</span>;i++) mod=mod*<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp1[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=k;j++) dp1[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=j) &#123;</span><br><span class="line">            dp2[i][j]=dp2[i-j][j]+dp2[i][j<span class="number">-1</span>]+(dp1[i-j][j]+dp1[i][j<span class="number">-1</span>])/mod;</span><br><span class="line">            dp1[i][j]=(dp1[i-j][j]+dp1[i][j<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp1[i][j]=dp1[i][j<span class="number">-1</span>];</span><br><span class="line">            dp2[i][j]=dp2[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp2[n][k]) <span class="built_in">printf</span>(<span class="string">"%lld"</span>,dp2[n][k]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp1[n][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> xyw </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> dp </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xyw_2019年8月4日</title>
      <link href="/2019/08/03/xyw_day_20190804/"/>
      <url>/2019/08/03/xyw_day_20190804/</url>
      
        <content type="html"><![CDATA[<h1 id="xyw5vplus1-2019-08-04"><a href="#xyw5vplus1-2019-08-04" class="headerlink" title="xyw5vplus1_2019.08.04"></a>xyw5vplus1_2019.08.04</h1><p>今天也没有花很多时间在ACM上</p><p>基本整天都处于放松状态</p><p>只是觉得放松久了需要写点题，不然今天的生活可能会失去色彩，</p><a id="more"></a><p>毕竟貌似某位哲人曾经说过（先剧透一下，是尼采，不是鲁迅），每一个不曾做题的日子，都是对生命的辜负</p><p>（其实下午的游泳还是很舒服的啦</p><p>扯回来</p><p>今天切了几道蛮简单的DP题，基本是挑战程序设计竞赛第二章的课后DP习题</p><p>不过有几个题确实给我带来一些新的启发，以及最后一个题教会我一个小Trick（见今天的另一篇博客 POJ 3181 解题报告）</p><p>今日得到：</p><p>​    拆分类的题目   <strong>往往转移的分类依据是根据最大或者最小元素来分类讨论的</strong>，</p><p>​    比如普通的正整数拆分，就是根据最小元素是不是0来分类的，而那道拆分成2的幂次的题，则是根据最大元素的大小来分拆的。</p><p>​    这样做的原因我想是因为，只要能去掉一个元素，就能使总和那一维度减小，就能实现递推，而如果最值元素是像我们想的那样的极端元素，我们可以把它去掉；如果不是，虽然我们不能使总和变小，但我们可以通过某些一一对应关系来建立数量关系，依然用一个已经计算的状态去转移到当前状态。</p><p>​    小Trick是当最后的数据稍稍超过了long long 的话，并且在转移的时候以加法和乘法为主的话，我们可以用两个long long 分别存下高位和低位的答案，避免使用比较慢的高精度。</p><p>最后，其实尼采的原话是每一个不曾起舞的日子，都是对生命的辜负。</p><p>那就把做题看成是大脑起舞的过程吧~</p>]]></content>
      
      
      <categories>
          
          <category> xyw </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> xyw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2279解题报告</title>
      <link href="/2019/08/02/POJ%202279/"/>
      <url>/2019/08/02/POJ%202279/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2279解题报告"><a href="#POJ-2279解题报告" class="headerlink" title="POJ 2279解题报告"></a>POJ 2279解题报告</h1><p>大致意思是：</p><p>现在有n个人，要排成k行，每行分别是n1,n2,……,nk的人，每个人分别有一个编号，要求每个人的编号要小于他左边和上面的，问有多少种满足题意的方案。</p><p>数据范围 n&lt;=30 k&lt;=5  </p><a id="more"></a><p>并没有什么思路……</p><p>《算法竞赛进阶指南》告诉我们，<strong>DP应该是从一个或几个起点出发，从已知的状态空间的边界点上向还没有被计算的状态空间扩展，最后扩展完整个问题的状态空间。</strong></p><p>我们应该选取<strong>一个不可逆的方向</strong>去思考这个过程，如果我们规定编号从小到大依次去考虑，那么，现在每增加一个元素，都是把这个元素选择一行然后放在最右边的过程，所以转移的分类讨论就是建立在具体选取哪一行。</p><p>当<strong>序</strong>确定下来之后，应该考察<strong>新增加进来更新的元素是如何改变当前的“状态”</strong>（假设我们这边还没有想出状态是什么）的，那么<strong>中间一些产生的差别，就可以作为状态表示的参考</strong>，</p><p>就像本题，当一个元素增加进来之后，唯一变化的应该是有某一行的长度变长了，那么应该是需要用每一行的长度去标记状态，这里的一个小的思考的trick是转移的时候要求当前行已经填的元素个数要比上一行少，我推测这里是有一些题目上没有说清楚的地方，应该要保证n1&gt;=n2&gt;=……&gt;=nk，那么这样的话，当本行元素已经跟上一行元素一样多的时候，如果我这里在本行放了，那么上一行之后放的元素一定比我当前行的元素要大了，所以不满足题意的要求，这个思考的trick也是对于看题解的我不太好想到的，</p><p>当确定了状态的表示之后，转移的条件什么的比较也都要用状态的某一维度或者与状态的某一维度一一对应的量去表示。或许我觉得我这题被卡住的最大的问题就在于这里，<strong>如何用一个量去表示出元素的大小关系</strong>，没想到竟然可以<strong><em>用数量关系去表述出大小关系</em></strong>！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> ui;</span><br><span class="line">ui dp[<span class="number">31</span>][<span class="number">16</span>][<span class="number">11</span>][<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> len[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF&amp;&amp;n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(len,<span class="number">0</span>,<span class="keyword">sizeof</span>(len));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;len[i]);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1=<span class="number">0</span>;i1&lt;=len[<span class="number">1</span>];i1++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2=<span class="number">0</span>;i2&lt;=len[<span class="number">2</span>];i2++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i3=<span class="number">0</span>;i3&lt;=len[<span class="number">3</span>];i3++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i4=<span class="number">0</span>;i4&lt;=len[<span class="number">4</span>];i4++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i5=<span class="number">0</span>;i5&lt;=len[<span class="number">5</span>];i5++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i1&lt;len[<span class="number">1</span>]) dp[i1+<span class="number">1</span>][i2][i3][i4][i5]+=dp[i1][i2][i3][i4][i5];</span><br><span class="line">                <span class="keyword">if</span> (i2&lt;len[<span class="number">2</span>]&amp;&amp;i2&lt;i1) dp[i1][i2+<span class="number">1</span>][i3][i4][i5]+=dp[i1][i2][i3][i4][i5];</span><br><span class="line">                <span class="keyword">if</span> (i3&lt;len[<span class="number">3</span>]&amp;&amp;i3&lt;i2) dp[i1][i2][i3+<span class="number">1</span>][i4][i5]+=dp[i1][i2][i3][i4][i5];</span><br><span class="line">                <span class="keyword">if</span> (i4&lt;len[<span class="number">4</span>]&amp;&amp;i4&lt;i3) dp[i1][i2][i3][i4+<span class="number">1</span>][i5]+=dp[i1][i2][i3][i4][i5];</span><br><span class="line">                <span class="keyword">if</span> (i5&lt;len[<span class="number">5</span>]&amp;&amp;i5&lt;i4) dp[i1][i2][i3][i4][i5+<span class="number">1</span>]+=dp[i1][i2][i3][i4][i5];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%u\n"</span>,dp[len[<span class="number">1</span>]][len[<span class="number">2</span>]][len[<span class="number">3</span>]][len[<span class="number">4</span>]][len[<span class="number">5</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> xyw </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> dp </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cm_2019年8月3日</title>
      <link href="/2019/08/02/cm_day_20190803/"/>
      <url>/2019/08/02/cm_day_20190803/</url>
      
        <content type="html"><![CDATA[<p>高峰还是挺心累的…</p><a id="more"></a><h1 id="白天"><a href="#白天" class="headerlink" title="白天"></a>白天</h1><p>涉及到一些敏感的东西，就不说了。</p><h1 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h1><p>今天一天其实没怎么碰acm，除了写了个题解之外，其实还挺惭愧的。就聊聊其他事吧，反正随便写。</p><p>杨和苏最近出了首歌，《决不投降》，真的棒，里面有几个很巧妙的押韵，<code>神志不清，人事不省，肯定不行</code>学到了。语速虽然不快，但是flow是真的棒，光从学这首歌的费劲程度就能看出来。用了一晚上学会了，虽然有点费嗓子，但是真的好听。词也很棒！！！希望自己以后也能达到这种高度！</p>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> cm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM_错误统计</title>
      <link href="/2019/08/01/ACM_wrongcount_20190802/"/>
      <url>/2019/08/01/ACM_wrongcount_20190802/</url>
      
        <content type="html"><![CDATA[<h1 id="失败是成功之母！今天起开始好好记录自己的错误！"><a href="#失败是成功之母！今天起开始好好记录自己的错误！" class="headerlink" title="失败是成功之母！今天起开始好好记录自己的错误！"></a>失败是成功之母！今天起开始好好记录自己的错误！</h1><p>本博客用来统计各位队员在平常做题，比赛，训练中犯得错误，时刻提醒自己。</p><a id="more"></a><h1 id="cm"><a href="#cm" class="headerlink" title="cm"></a>cm</h1><table><thead><tr><th>错误</th><th align="center">最近一次犯错时间</th><th align="center">次数</th></tr></thead><tbody><tr><td>主席树中，该使用左右孩子节点的时候，使用了自身节点</td><td align="center">2019-08-01</td><td align="center">3</td></tr><tr><td>主席树中，左右节点搞错</td><td align="center">2019-08-03</td><td align="center">2</td></tr><tr><td>treap中，搞错节点</td><td align="center">2019-08-09</td><td align="center">2</td></tr><tr><td>写错变量名</td><td align="center">2019-08-06</td><td align="center">4</td></tr><tr><td>读入时传错变量</td><td align="center">2019-08-02</td><td align="center">1</td></tr><tr><td>临界情况未考虑</td><td align="center">2019-08-02</td><td align="center">1</td></tr><tr><td>数据范围算错</td><td align="center">2019-08-06</td><td align="center">2</td></tr><tr><td>想太复杂而且钻牛角尖</td><td align="center">2019-08-08</td><td align="center">3</td></tr><tr><td>用太多stl导致内存超了</td><td align="center">2019-08-09</td><td align="center">1</td></tr><tr><td>没有看到是多组数据</td><td align="center">2019-08-09</td><td align="center">1</td></tr><tr><td>格式错误</td><td align="center">2019-08-09</td><td align="center">1</td></tr><tr><td>变量引用搞错</td><td align="center">2019-08-13</td><td align="center">1</td></tr></tbody></table><h1 id="xyw"><a href="#xyw" class="headerlink" title="xyw"></a>xyw</h1><table><thead><tr><th>错误</th><th align="center">最近一次犯错时间</th><th align="center">次数</th></tr></thead><tbody><tr><td>题读错</td><td align="center">2019-08-02</td><td align="center">1</td></tr><tr><td>无向图有向图看错</td><td align="center">2019-07-22</td><td align="center">2</td></tr><tr><td>矩阵快速幂指数处理不当，出现负数，导致T</td><td align="center">2019-08-05</td><td align="center">2</td></tr><tr><td>计算幂次的时候如果指数特别大需要取模，要注意不是对p取模，而是对p-1取模(p是质数的情况下，否则应该用欧拉降幂公式)</td><td align="center">2019-08-05</td><td align="center">2</td></tr><tr><td>离散化之后查询元素的排名时二分的下标写错</td><td align="center">2019-08-05</td><td align="center">1</td></tr><tr><td>忘记关掉Debug(尤其是那些输出中间过程的，不只是单纯去掉输出就可以了，可能会导致T掉)</td><td align="center">2019-08-05</td><td align="center">2</td></tr><tr><td>没有想清楚主席树底层维护的元素是什么</td><td align="center">2019-08-05</td><td align="center">1</td></tr><tr><td>query的时候往右子树跑的时候k忘减cnt了</td><td align="center">2019-08-06</td><td align="center">1</td></tr><tr><td>矩阵快速幂的时候模超过int，没有用快速乘法导致爆long long</td><td align="center">2019-08-10</td><td align="center">1</td></tr><tr><td>素数传值的时候没有想清楚传的是绝对大小（值本身）还是相对大小（第几个素数）</td><td align="center">2019-08-11</td><td align="center">1</td></tr><tr><td>在一个元素对主席树上的元素完全没有修改的时候，依然需要把根节点复制一份，不然会影响后面其他节点建主席树的时候的正确性</td><td align="center">2019-08-11</td><td align="center">1</td></tr></tbody></table><h1 id="key"><a href="#key" class="headerlink" title="key"></a>key</h1><table><thead><tr><th>错误</th><th align="center">最近一次犯错时间</th><th align="center">次数</th></tr></thead><tbody><tr><td>数据范围估错</td><td align="center">2019-08-10</td><td align="center">1</td></tr><tr><td>变量名写错</td><td align="center">2019-08-11</td><td align="center">2</td></tr><tr><td>多组数据</td><td align="center">2019-08-10</td><td align="center">1</td></tr><tr><td>循环的时候 i 和 j 写混</td><td align="center">2019-08-11</td><td align="center">2</td></tr><tr><td>读错题</td><td align="center">2019-08-11</td><td align="center">1</td></tr><tr><td>除法忘加double</td><td align="center">2019-08-12</td><td align="center">1</td></tr><tr><td>扫描小于$\sqrt n$的素数分解$n$时，忽略$n$为素数的情况</td><td align="center">2019-08-12</td><td align="center">2</td></tr><tr><td>快速幂mod为long long时，相乘爆long long</td><td align="center">2019-08-12</td><td align="center">1</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> acm队伍相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 错误统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cm_2019年8月2日</title>
      <link href="/2019/08/01/cm_day_20190802/"/>
      <url>/2019/08/01/cm_day_20190802/</url>
      
        <content type="html"><![CDATA[<p><em>其实这边日报是八月三号写的，因为昨天实在是太累，又要早起，就先早睡了</em></p><p>以后准备统计日常犯得错误，发现最近写主席树经常会犯很多弱智错误……</p><a id="more"></a><h1 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h1><p>依然，做了一些codeforces上的题，有个dp，还算比较简单的那种，大概很最大子段和有点像，有个异或有关的题，一开始无脑想kmp（题目本身有点字符串匹配的意思），但是写到一半突然发现复杂度不对， 再想想，觉得扫一遍就可以了，感觉自己好弱智，耽误了十多分钟。<strong>以后敲之前一定要想清楚一些</strong>，不要无脑上手。</p><p>还有个最小生成树的题，题目描述读了好久，简单说就是，改变一个边的权值，使得这个边在最小生成树之一中，问这个边值最大能是多少，kruscal搞一下就行了，不难。</p><p>剩下题比较好想。</p><h1 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h1><p>下午收获还是很多的，继续嘴巴ac，一些hdu上的题能很快想到，codeforces上的题就没那么裸了。</p><p>有个题需要快速求矩形能点的个数，学到原来主席树搞一下可以出了这类操作。</p><p>还有个很巧妙的统计区间不同数个数的题，建树很巧妙，同时复杂度也很有文章可以做，等下专门放在题解里讲</p><h1 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h1><p>晚上有点自闭，果然嘴巴ac上远远不够的，一道题还是调了好久，好在最后是过了</p><p>看完了最新一期的《中国新说唱2019》，还是有挺多感触的。这期很精彩，新秀牛逼，黄旭牛逼，其他人也牛逼。有些如觉得呛别人何必呢，然而这才是battle的乐趣啊，有些如觉得黄旭作作，被diss了，diss回去没毛病啊，而且《天堂来信》这首歌，对黄旭的意义多深知道吗，就算急眼了，也可以理解，要是可以说脏话，你是没见过真正的battle，这种比赛，就是该有炸点有看点才精彩好吗。当然，love&amp;peace也是看点。虽然节目里doooboi没有展现出来这个位置应该有的实力，但这也并不影响我听他的歌。</p><p>有些人看个说唱，讨厌这个，烦那个，真当这是选秀节目啊，饭圈那一套也逐渐被带过来了。就像膜老师说的，真正的hiphop，还是小众。</p><p>我看这个节目，基本不会去讨厌任何一个rapper，真正讨厌的，也就只有节目组的一些行为和一些一些傻x赛制。</p>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> 主席树 </tag>
            
            <tag> cm </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 观后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xyw_2019年8月2日</title>
      <link href="/2019/08/01/xyw_day_20190802/"/>
      <url>/2019/08/01/xyw_day_20190802/</url>
      
        <content type="html"><![CDATA[<p>上午继续树形背包，面向题解的编程</p><p>区间DP Wa到自闭，可能还要多做点题才能融汇贯通，现在还处在 </p><p>嗯我觉得我想出正解了，果然轻松过样例，卧槽，居然WA了，然后就自闭了</p><p>能明白别人的是对的，但就是不知道自己的为什么错了</p><p>下午继续嘴巴做主席树，几个n/1+n/2+……+n/n的题还挺有意思的，</p><p>不少HDU的脑补切题觉得还挺容易的，但就怕到时候写不出来</p><p>CF的几道题还挺难的</p><p>晚上继续写主席树，简单的区间第K大已经比较有把握了，但是稍微复杂一点的还是会写残</p><p>明天视心情决定是不是打牛客多校</p><p>晚上最后看了树上讲解的高斯消元，准备整理到板子里去</p>]]></content>
      
      
      <categories>
          
          <category> xyw </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> xyw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基础语法</title>
      <link href="/2019/07/31/markdown_base_20190731/"/>
      <url>/2019/07/31/markdown_base_20190731/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown快速上手"><a href="#markdown快速上手" class="headerlink" title="markdown快速上手"></a>markdown快速上手</h1><h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>首先是一些基础功能</p><a id="more"></a><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>通过<code>#</code>设置标题大小</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>代码如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题 #</span></span><br><span class="line"><span class="section">## 二级标题 ##</span></span><br><span class="line"><span class="section">### 三级标题 ###</span></span><br></pre></td></tr></table></figure><h3 id="有序-无序列表"><a href="#有序-无序列表" class="headerlink" title="有序/无序列表"></a>有序/无序列表</h3><p>通过<code>-.</code>或者<code>x.</code>（x为数字)的形式</p><ol><li>test1<ol><li>test1.1</li><li>test1.2</li></ol></li><li>test2</li><li>test3</li></ol><ul><li>test4<ul><li>test4.1</li><li>test4.2</li></ul></li><li>test5</li><li>test6</li></ul><p>代码如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>test1</span><br><span class="line"><span class="bullet">1. </span>test1.1</span><br><span class="line"><span class="bullet">2. </span>test1.2</span><br><span class="line"><span class="bullet">2. </span>test2</span><br><span class="line"><span class="bullet">3. </span>test3</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>test4</span><br><span class="line"><span class="bullet">- </span>test4.1</span><br><span class="line"><span class="bullet">- </span>test4.2</span><br><span class="line"><span class="bullet">- </span>test5</span><br><span class="line"><span class="bullet">- </span>test6</span><br></pre></td></tr></table></figure><h3 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h3><p><em>斜体</em> ：<code>*斜体*</code></p><p><strong>加粗</strong>：<code>**加粗**</code></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p><code>---</code></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><code>&gt;</code></p><hr><p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com" target="_blank" rel="noopener">链接</a>。下面列举了几个高级功能，具体方法可以参加github中该文章的<a href="https://raw.githubusercontent.com/DcmTruman/DcmTruman.github.io/blog_source/source/_posts/markdown_base_20190731.md" target="_blank" rel="noopener">源文件</a></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><h3 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h3><p>可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p><p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th align="left">Item</th><th align="right">Value</th><th align="center">Qty</th></tr></thead><tbody><tr><td align="left">Computer</td><td align="right">1600 USD</td><td align="center">5</td></tr><tr><td align="left">Phone</td><td align="right">12 USD</td><td align="center">12</td></tr><tr><td align="left">Pipe</td><td align="right">1 USD</td><td align="center">234</td></tr></tbody></table><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p><ul><li><input checked disabled type="checkbox"> 已完成事项</li><li><input disabled type="checkbox"> 待办事项1</li><li><input disabled type="checkbox"> 待办事项2</li></ul>]]></content>
      
      
      <categories>
          
          <category> acm队伍相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm队伍相关 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客使用说明</title>
      <link href="/2019/07/31/blog_instructions_20190801/"/>
      <url>/2019/07/31/blog_instructions_20190801/</url>
      
        <content type="html"><![CDATA[<p>本博客基于hexo melody主题搭建，队员初次构建个人博客可以参考此文章</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p>博客由markdown格式书写，文件名统一规定为<code>博客英文名_20xx-xx-xx.md</code>，文件名请使用英文，不熟悉markdown的请先学习<a href="https://dcmtruman.github.io/2019/07/31/markdown_base_20190731/">markdown基础用法</a></p><p>完成之后使用个人在github文件到<a href="https://github.com/DcmTruman/DcmTruman.github.io/tree/blog_source/source/_posts" target="_blank" rel="noopener">该网站目录下</a>,记得上传的时候填写commit</p><p><img src="https://b2.bmp.ovh/imgs/2019/08/f3c5efed2fbefa5e.png" alt="上传博客"></p><p>稍等片刻，travis CI将会自动构建新的博客，延迟大概在五分钟</p><p><strong>注意</strong> ：博客在首页预览时会自动节选前150字，但会影响排版，如果有美观需求，请手动添加<code>&lt;!-- more --&gt;</code>决定预览位置</p><a id="more"></a><h1 id="文件头：文章名、目录、标签和日期"><a href="#文件头：文章名、目录、标签和日期" class="headerlink" title="文件头：文章名、目录、标签和日期"></a>文件头：文章名、目录、标签和日期</h1><p>任何一个文章都有它的出生地，我们需要在每篇博客前加上头文件形如，将<code>top</code>属性置位<code>True</code>可以实现<strong>置顶效果</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">博客标题</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">标签1</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">标签2</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">一级目录</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">二级子目录</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">三级子目录</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-3</span><span class="bullet">-17</span></span><br><span class="line"><span class="attr">top:</span> <span class="literal">False</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>关于目录结构暂时如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">站点:.       </span><br><span class="line">├─acm队伍相关 </span><br><span class="line">│  ├─基本说明 </span><br><span class="line">│  ├─训练计划 </span><br><span class="line">│  └─队伍总结 </span><br><span class="line">├─cm      </span><br><span class="line">│  ├─acm题解</span><br><span class="line">│  ├─日报</span><br><span class="line">│  └─......  </span><br><span class="line">├─key      </span><br><span class="line">│  ├─acm题解</span><br><span class="line">│  ├─日报</span><br><span class="line">│  └─......   </span><br><span class="line">├─xyw      </span><br><span class="line">│  ├─acm_题</span><br><span class="line">│  ├─日报</span><br><span class="line">│  └─......</span><br><span class="line">└─......</span><br></pre></td></tr></table></figure><p>为了方便检索管理，统一部分标签的使用</p><ul><li><p>cm/xyw/key：文章作者标签</p></li><li><p>acm题解：与acm题题解相关的博客</p></li><li><p>学习笔记：学习笔记</p></li><li><p>每日总结：每日总结</p></li><li><p>队伍总结：与队伍相关的总结</p></li><li><p>总结 or 心得 ：总结或者心得</p></li><li><p>教程：发布个人教程</p></li><li><p>杂谈：与学习知识没有直接相关的，比如思考的某些事，作品观后感，旅游心得或者自己最近的想法等，都行，灵活使用</p></li></ul><p>其他标签大家随意发挥</p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>如果已经学会使用markdown语法了，肯定知道，在插入图片的时候是需要图片地址的，特此规定一下，<strong>禁止将博客图片直接放到词博客项目的github地址上</strong>，可以push到个人仓库，也可以用一些图片资源托管网站注入<a href="https://imgurl.org/" target="_blank" rel="noopener">ImgURL</a></p><p><img src="https://b2.bmp.ovh/imgs/2019/08/b1719bf3683d8511.png" alt></p><h1 id="幻灯片"><a href="#幻灯片" class="headerlink" title="幻灯片"></a>幻灯片</h1><p>如果是纯幻灯片，基础用法如下,注意文件开头的<code>layout: slides</code>部分,<a href="https://dcmtruman.github.io/2019/07/30/test_slide/">预览地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 一个幻灯片测试用例</span><br><span class="line">tags: </span><br><span class="line">  - 功能测试</span><br><span class="line">categories:</span><br><span class="line">  - 功能测试</span><br><span class="line">date: 2019-7-31</span><br><span class="line">layout: slides</span><br><span class="line">slide:</span><br><span class="line">  theme: night</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 按理说这是第一页</span><br><span class="line"></span><br><span class="line">- 1.1</span><br><span class="line">- 1.2</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">- 2.3</span><br><span class="line">- 2.3</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># 按理说这是第二部分</span><br><span class="line"></span><br><span class="line">- 3.2</span><br><span class="line">- 3.3</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">hahaha</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm队伍相关 </category>
          
          <category> 基本说明 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm队伍相关 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cm_2019年8月1日</title>
      <link href="/2019/07/31/cm_day_20190801_2/"/>
      <url>/2019/07/31/cm_day_20190801_2/</url>
      
        <content type="html"><![CDATA[<h1 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h1><p>挑了几道题，同时补了一下之前在codeforces上遇到的一个题，标答给的做法是名次树，treap，实现使用stl，也因此，<code>treap</code>成了我这几天特别想学习的东西（之一），这个周末如果不忙，会去看看。</p><p>当然也有一种离线做法，需要提前处理出来询问，按照从小到大的顺序在权值线段树上询问和更新，也比较好理解，但是，今天还看到一个很棒的做法，代码量非常少，改天有空会专门写一下题解。</p><h1 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h1><p>吃完午饭后，和师弟开始研究习题，今天下午的学习方法是这样的，重点培养对于数据结构这一类题的思维能力，暂时先不开始敲（俗称，嘴巴ac）毕竟放在下午的话，可能思维上会了，但是调试一下午就很没有效率，我晚上或者其他空闲时间，在主要开始切一些这样的题。</p><p>看了很多bzoj的题，收获还是很多的，想大概说一下</p><a id="more"></a><h2 id="Bzoj-2653"><a href="#Bzoj-2653" class="headerlink" title="Bzoj-2653"></a>Bzoj-2653</h2><p>这道题很有意思，也加深了我对「可持久化线段树」的理解。</p><p>题目大意是，左端点给你一个可选范围，右端点给你一个可选范围，然后你决定左右端点，使得其形成的区间的中位数最大。</p><p>我想到二分中位数了，想着根据当前中位数，判断一下 左右区间+中间区间 能不能构成我这种中位数情况，说白了就是看一下比当前值<code>x</code>大的有多少个数，比<code>x</code>小的有多少个数，但由于是连续选取，所以突然有点懵不知道该怎么维护。</p><p>后来师弟说<strong>线段树最大连续子段和</strong>之后，再利用+1、-1这种数值记录的方式。仿佛有了点眉目。</p><p>题解做法是，初始一颗线段树，每个叶子结点是当前位置对应的信息，初始是全为+1，然后对于原序列，按照数值从小到大的顺序，更新这个线段树，每次更新，都去更新其在原数组中的位置，将其置位-1。</p><p>这样一来，对于任何一个在数组中的值，我都有一个包含区间信息的+1，-1线段树，更新使用可持久化思想，每次只更新部分信息，根据二分的值我们在此二分能找到一个与之对应的中位数，得到这个中位数下的求最大子段信息。</p><p>具体代码和做法，之后会补上。</p><p>很多人的解题博客上写着「主席树」，我觉得并不妥当，在这里向和传统主席树的应用做个比较。</p><table><thead><tr><th></th><th>区间第k大</th><th>此题</th></tr></thead><tbody><tr><td>维护信息</td><td>值域上每个数的分布</td><td>每个版本原数组区间的信息</td></tr><tr><td>根节点信息</td><td>将区间序列表示成一种有序的时间更新序列</td><td>按照数值排序，不断修改线段树，更新部分信息</td></tr><tr><td>利用</td><td>利用可减性，将「历史版本」变成「区间信息」</td><td>比较纯粹的「可持久化」思想，为了使用许多个不同版本的线段树</td></tr></tbody></table><h2 id="Bzoj-3932"><a href="#Bzoj-3932" class="headerlink" title="Bzoj-3932"></a>Bzoj-3932</h2><p>求区间前k小的和，这一部分不多说了，之所以也写在日报里是一个地方出了笔误，<strong>本来应该求左儿子的节点个数信息，我写成当前儿子了，实在是坑死我了</strong></p><p>其实主席树的一个特点，也可以让我们更好的去思考这类题，每次更新都是一个点，我们见到这样的题，完全可以先考虑，在这道题中，有没有什么操作是单点或者能转换成单点操作的。比如本题中，虽然线段是覆盖，但可以看成是左端点+一个值，右端点-一个值，就能按照题目中与时间有个的关键点维护权值线段树，得到不同时间点的前k大的和。</p><p>对于输入中任何一个时间点，二分找到小于等于它的最大的那个时间点，根据其对应的权值线段树，得到答案。</p><h2 id="Bzoj-3123"><a href="#Bzoj-3123" class="headerlink" title="Bzoj-3123"></a>Bzoj-3123</h2><p>启发式合并，一开始看到之后想过能不能暴力这么搞，但因为自己太菜+经验不足，就自我否定了这个想法，后来看到这个题的tag，才恍然大悟。</p><p>时候诸葛亮一下，又是始终保证森林，又是树上一个点接到另一个上面，明示合并能搞啊，这部分的复杂度$log_{2}n$，不该怂的，真的很巧妙啊。</p><hr><p>等下准备去更新一下 <strong>acm错误统计</strong>，然后睡觉！ </p>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> 主席树 </tag>
            
            <tag> cm </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xyw_2019年8月1日</title>
      <link href="/2019/07/31/xyw_day_20190801/"/>
      <url>/2019/07/31/xyw_day_20190801/</url>
      
        <content type="html"><![CDATA[<h1 id="20190801-总结"><a href="#20190801-总结" class="headerlink" title="20190801 总结"></a>20190801 总结</h1><p>嗯，结束了昨天的颓废生活，今天继续开开心心学东西</p><p>上午写了个树形背包，过了两个模板题（虽然调了很久</p><p>下午开始可持久化数据结构的学习，看了5道BZOJ的题</p><p>其中印象比较深的有middle那题</p><a id="more"></a><p>二分答案，把元素从小到大排序，然后依次建可持久化线段树，再查询区间的一些信息</p><p>感觉因为<strong>最后是针对值查询区间的一些信息的，所以应该用可持久化线段树来维护</strong>，</p><p><strong>可持久化权值线段树是以每个元素作为根，底层维护的是权值信息而不是区间信息</strong></p><p>任务优先级前k大的那个题</p><p>用排序扫描的思想做，思路基本能想明白的</p><p>然后最后那个启发式合并的感觉也特别棒，大致想清楚了复杂度的问题</p><p><strong>有时候在暴力的基础上加个启发式就是正解了</strong></p><p>晚上的DP训练，想了一个Zuma的做法，但是WA Test 5 了，最后是看题解补的，有点不敢确定为什么转移的式子写的这么简单，但它又确实是对的……</p><p><strong>转移的时候总是应该建立一个不重不漏的划分，然后分类讨论地转移</strong>，或许这种区间DP见到还是少了一些</p><p>树上的那个什么GCD&gt;1的情况下求距离最大的也不太会做，大致看明白了题解的思路</p><p>明天的话上午应该是继续写写树形背包，然后补补之前的题，下午继续刚可持久化数据结构，哦对，终于完全看明白了主席树的写法。</p><p><strong>这周的重中之重就是主席树！</strong></p>]]></content>
      
      
      <categories>
          
          <category> xyw </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> 主席树 </tag>
            
            <tag> xyw </tag>
            
            <tag> 可持久化权值线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cm_2019年7月31日</title>
      <link href="/2019/07/30/cm_day_20190801/"/>
      <url>/2019/07/30/cm_day_20190801/</url>
      
        <content type="html"><![CDATA[<ol><li><p>因为胃疼原因去开了一些药.</p></li><li><p>补了两道主席树的题，模板基本可以不出错自己敲下来了，明天试一试把递归换成<code>while</code>循环，省去一些递归的自身开销，勉强算是一点微小的优化。发现，相比于把左右孩子之一接过来，在修改另一个孩子这种写法，一开始直接先全部拷贝过来，在修改需要改的节点，会在实现上优雅很多，「拷贝」这个操作，可以单写一个<code>copy</code>函数，也可以直接用结构体的赋值</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> lr,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> vl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=++tot;tree[x]=tree[lr];tree[x].sum++;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r)&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(vl &lt;= mid)update(tree[lr].l,tree[x].l,l,mid,vl);</span><br><span class="line">    <span class="keyword">else</span> update(tree[lr].r,tree[x].r,mid+<span class="number">1</span>,r,vl);</span><br><span class="line">    <span class="comment">//tree[x].sum = tree[tree[x].l].sum + tree[tree[x].r].sum;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="3"><li><p>写了博客的使用说明，markdown语法基本说明，规划了一下目录结构等，希望以后这个博客能用起来，队友也可以在这个博客上发文章，无论是否有关acm，。我以后会以此博客为主力博客。</p></li><li><p>有点想日后在博客上加上相册功能，但还没找到免费好用且不限量的图片托管平台。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> cm </category>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日总结 </tag>
            
            <tag> 主席树 </tag>
            
            <tag> cm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个幻灯片测试用例</title>
      <link href="/2019/07/30/test_slide/"/>
      <url>/2019/07/30/test_slide/</url>
      
        <content type="html"><![CDATA[<h1 id="按理说这是第一页"><a href="#按理说这是第一页" class="headerlink" title="按理说这是第一页"></a>按理说这是第一页</h1><ul><li>1.1</li><li>1.2</li></ul><p>–</p><ul><li>2.3</li><li>2.3</li></ul><hr><h1 id="按理说这是第二部分"><a href="#按理说这是第二部分" class="headerlink" title="按理说这是第二部分"></a>按理说这是第二部分</h1><ul><li>3.2</li><li>3.3</li></ul><hr><p>hahaha</p>]]></content>
      
      
      <categories>
          
          <category> 功能测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 功能测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
