---
title: cm_字符串相关习题
tags: 
  - 字符串
  - 题目
  - 后缀数组
categories:
  - cm
  - 字符串
date: 2019-08-28
top: False
---

# cm_字符串相关习题

小灯菜鸡一气之下，开始刚字符串！

 ╰（‵□′）╯

 ヽ(｀⌒´)ﾉ

 (*´ﾉ皿`)

<!-- more -->

## 后缀数组

- [x] HDU 6194 : 统计出现恰好k次的不同子串的个数 ，算贡献的时候减去前后height的max值
- [x] HDU 6704 : 在height上二分给定$L$的左右边界，对$sa$数组建主席树，求区间第k大
- [x] POJ 1743 ： 二分长度，按照长度对height分组，求每个组对应sa的最大最小值，如果大于长度，true
- [x] POJ 3415 : 给定两个串A和B ，求长度不小于k的公共子串的个数，先把连个字符串连接起来，求height，按照k对height数组，计算B对A的贡献，在计算A对B的贡献，问题在于，当遇到一个B的时候，如何快速求出和他前面每个A所产生的贡献？因为每次遇到一个B的后缀，都是与之前的所有A的后缀计算贡献，在求lcp的时候取最小值，之前每个位置到当前点的最小值肯定是费下降的，我们用单调栈维护，同时维护一下单调栈里应该计算的贡献之和，每遇到一个B，就把这个和加上。（改天应该练习一下单调栈的题）
- [x] 2019牛客第四场 I string。问你有子串，使得这些子串互不相同且也不等于其他子串的反串。正串反串拼起来，求本质不同的子串个数，然后加上原串中本质不同的回文串个数（回文自动机），然后除2就行了。
- [ ] 2018牛客多校第三场String，给你一个字符串，字符串每个位置的后缀+前缀可以得到一个新的字符串，让你统计这些字符串中有多少过不同的字符串。原字符串x2，然后hash一下放在map里即可，也可以x2以后统计多少个本质不同且长度为n的子串，按照n对height分一下组就可以了
- [x] HDU 5769 给定一个字符串S和一个字符X，统计包含X字符的本质不同的子串个数,处理出每个X的位置，预处理离每个后缀起始位置右边最近的X的位置，然后统计答案。
- [x] Codeforces123D ： 每个子串都和其他子串进行尽可能多的匹配，算总次数，在后缀数组上，每个位置都和前面的每一个进行lcp，单调栈维护即可。
- [x] [2018焦作网络赛](https://nanti.jisuanke.com/t/A201) ： 这道题的关键在于，要统计出现大于等于k次的子串，想象在height数组上有一个滑动窗口，每连续k个区间的lcp肯定至少出现过k次，我们每次计算完都要减去上一次计算出来的答案，如果大于0在相加，避免一些字符串算重复了。
- [x] 2017icpc 青岛 suffix  当时打铁很难受，字符串题最终还是没敢试暴力。**从后往前拼**，拼出来的串求一发后缀数组，找到字典序最小的在原字符串的后缀，然后和上一个拼，如此重复
- [x] POJ 3261 找到尽可能长的子串，该子串至少出现k次（可重叠）, 二分长度，按照长度分组，每组个数表示出现多少次，判断存不存在个数大于等于k的即可
- [x] SPOJ - REPEATS 重复次数最多的连续重复子串，论文里有，讲的比较清楚了。这里有个实现上的点，往后匹配尽可能多的字符，我们可以通过后缀字符得到，往前匹配尽可能多的字符如何做呢？一开始我的想法是反串在建一个后缀数组，就是多个常数的事，确实也可以。别人的题解里，比如当前枚举的长度是L，只需要看一下匹配长度%枚举长度多出来几个字符，就再往前查看（L - 多出来的字符）,判断能不能再凑一个循环节，以利用这些多出来的字符即可。可是为什么只用查看这些而不全匹配呢？因为如果往前会匹配到更多的，那么在之前的枚举中我们必然已经遇到过了。这部分如果不太理解那就反串再建一遍好了。
- [x] HDU 5008 找出本质不同的字符串中，第k小的，输出左右端点。如果有多个，输出左端点最小的那个。处理除了对于每个后缀，每次新增多少个，因为后缀数组本来就是字典序，所以二分就行了，但同时也要往后枚举一下，看看后面是否有左端点更小的。

顺便贴一发我的板子,字符串下标从0开始，Rank数组、sa数组和height下标才1开始，sa数组的值（即原始字符串位置）从0开始。DA的参数n是原始字符串长度+1，r数组切记把`r[n]`置为一个未出现的数字

```c++
int wa[N],wb[N],Ws[N],wv[N];
int Rank[N],height[N],root[N],n,m,st[maxn][25];
int k;
void DA(int *r,int *sa,int n,int m){ 
    int i,j,p,*x=wa,*y=wb,*t;
    for(i=0;i<m;i++) Ws[i]=0;
    for(i=0;i<n;i++) Ws[x[i]=r[i]]++;
    for(i=1;i<m;i++) Ws[i]+=Ws[i-1];
    for(i=n-1;i>=0;i--) sa[--Ws[x[i]]]=i; 
    for(j=1,p=1;p<n;j*=2,m=p) 
    {
        for(p=0,i=n-j;i<n;i++) y[p++]=i; 
        for(i=0;i<n;i++) if(sa[i]>=j) y[p++]=sa[i]-j; 
        for(i=0;i<n;i++) wv[i]=x[y[i]];
        for(i=0;i<m;i++) Ws[i]=0;
        for(i=0;i<n;i++) Ws[wv[i]]++;
        for(i=1;i<m;i++) Ws[i]+=Ws[i-1];
        for(i=n-1;i>=0;i--) sa[--Ws[wv[i]]]=y[i];  
        for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i<n;i++)
            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;  
    }
}

void calheight(int *r,int *sa,int n){ 
    int i,j,k=0;       
    for(i=1;i<=n;i++) Rank[sa[i]]=i;  
    for(i=0;i<n; height[Rank[i++]] = k ) 
    for(k?k--:0,j=sa[Rank[i]-1]; r[i+k]==r[j+k]; k++); 
} 

string sta[N];
char str[N];
int r[N];
ll r2[N];
ll pre[N];
int sa[N];
int getmin(int x,int y)
{
    //cout << x << " " << y << " ";
    if(x == y)return n - sa[x];
    if(x > y)swap(x,y);
	x ++;
    int ln = log2(y - x  + 1);
    int ret = min(st[x][ln] , st[y - (1 << ln) + 1][ln]);
	//cout << ret << endl;
	return ret;
}

```
