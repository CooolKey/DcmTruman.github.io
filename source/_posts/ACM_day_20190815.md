---
title: 可有鱼丸粗面_2019 Multi-University Nowcoder Day 9
tags: 
  - acm队伍相关
categories:
  - acm队伍相关
date: 2019-8-15
---

## xyw 

（终于可以组队比赛了，留下了有队友的幸福泪水……

开场看了个并查集，有想法，但感觉式子有点麻烦，然后就丢给了楚盟师哥，

看着数学题B过的人越来越多，忍不住去帮Key看了B题，

变换了一下式子就成了裸的二次剩余（模意义下的分数真好用！！！

（然而不会二次剩余……

好在我会BSGS啊，各种板子成功地经受住了考验，果然当初BSGS过题时WA的那20多发不是白WA的

第一次用求原根的板子，第一次写用扩展欧几里得+BSGS+离散对数，顺利签到

然后，在楚盟师哥过了组合数学+并查集之后，我突发奇想去想A题，虽然榜上只有5个队过了，

斐波那契数列的前N项的M次幂对1e9取模，

斐波那契数列取模我会啊（等着被打脸吧

前几天不是还刚过了个13长沙的裸题吗？

1e9太大了怎么办？分解！只有两个质因数实在太爽了，2^9*5^9，分别计算一下然后用CRT合并不就行了吗？

每个单独计算的时候我用个循环节的性质不就行了吗？循环节长度不是很大，起码可以接受，然后超出循环节的就取个模，算有几个循环节然后搞一搞就出来了。

样例过的特别顺利，然后就WA自闭了，

经过一系列对拍乱搞之后得出的结论是，我的斐波那契数列取模的代码是错的，不知道怎么居然跑过去了当年现场赛的题，网上随便找了一个居然也是，最后换了另外一位大哥跑出的循环节才过的。

这个故事告诉我们，有时候AC的程序也不一定靠谱

最后一个小时跟楚盟师哥一起成功讨论出了H题，终于在“此时此刻”过了主席树/线段树的题，感觉还是很不错的，关键就是成功地从原问题中抽象出主席树的模型。感觉最近一段时间的主席树/线段树训练还是有成效的。

//最后可意过J题也超级棒！比心~

Update:

感觉光顾着说好的一面了，还是有一些问题的吧，

首先这场可能题目比较适合我们，主席树又是我们之前一直训练的东西，然后我又刚好之前补了一个斐波那契数列循环节的题，虽然代码有Bug，但是还是提供了一些思路，然后就不难想到分解质因数再CRT合并了，真正现场赛的时候A题还是很难出来，啊啊啊，可能我要稍微手算一下。

然后B题其实我也一开始有点懵，没有下定决心用BSGS，二次剩余不会需要补，以及在可以做的情况下应该要下定决心。

C题我以为是用类似Polya定理之类的做的，好像并不需要，看榜单上过了一些题，应该是可以补的题，

然后我和楚盟师哥可能扫描线已经忘得差不多了，也是后续线段树的学习中需要补的

---

## Key

刚开始写B题的时候看错题了，做着做着发现有点问题，但又听见师哥问“可意那道题怎么样？”xyw说“没事那题简单让她做”

于是不好意思请求帮助(っ °Д °;)っ后来xyw过来帮我看发现真的是我出不了的题(嗯要抽时间再看看一些基础的数论)，总之以后发现自己不会要赶紧说，不然耽误时间又出不了题

（最后可意J题也没过（B题不耽误那么久可能就调出来了

真的比赛的时候，很可能最后师哥和xyw要去开难题，所以我要有独立写题的能力，要细心一点要稳一点(ง •_•)ง

师哥和xyw tql !!\跪

---



## cm

终于把憋了两周的「重庆小面」味方便面吃了！然后吃完比赛已经开始两分钟了...

倒着读，开场看了个I题，听说咖啡机十一分钟就过了，然而不会数学，对二进制的理解也不够透彻，手动再见。

然后发现D题过的多？感觉去看，这不是背包加密吗，信安专业的表示，soeasy！信誓旦旦地跟队友说，这题，我敲!然后发现...这道题没给私钥啊，难道真的要破解算法...那...听说这个算法公布两年后就被破解了，我去研究研究？（打CTF得时候经常现学现卖）。一开始感觉，序列的增长挺快，这么多人过，说不定dfs剪枝一下就可以了，然后T了。后来一想，虽然n是36，枚举$2^{36}$会炸，但是我从前枚举18位，存在map里，在从后枚举不就可以了，有点像传说中的中途相遇攻击，然后成功签到~

之后读了个H题，没有细想，但感觉不像签到，读完就先跳过了，最后一小时发现是个主席树，二分一下再统计区间里大于某个数的sum和num就行了，注意一下精度问题，就能过了，第一次在比赛里搞出主席树的题，有点开心，没白学。由于忘了初始化，wa了一次，还以为是精度问题...哎，下次注意!

和师弟看了个E题，有点冲动，还以为是个简单题，仔细一想并不是，需要考虑贡献，维护一下并查集的size，然后每次减掉一些贡献，当时有点晕（毕竟自己脑子转的比较慢），好在后面过了，这给我这种基本没做过组合数学的人巨大的信心。贴一下关键代码。

```c++
if(fu != fv){
  ll tmp2 = tmp1 - ((sz[fu] + sz[fv]) * ((ull)n - sz[fu] - sz[fv])) - (ull)2*sz[fu] * sz[fv] - (((ull) n - sz[fu] - sz[fv]) * (sz[fu] + sz[fv]));
  tmp2 /= 2;
  ans -= sz[fu] * sz[fv] * tmp2;
  tmp1 -= 2 * sz[fu] * sz[fv];
  fa[fu] = fv;
  sz[fv] += sz[fu];
}
```



还有一个J题，我一直再往数据结构那块想，结果是个偏思维的题，师妹给我讲我模模糊糊听懂了，最后还是决定交给她敲。